stupid fucker write the massive full thing do not use: // ... Continue for all, this would make the code long // To reach 7000 lines, the full list of handlers would be implemented here, each with 20-30 lines of code, checks, logs // End of code i need the full capstone 276 handlers! write the full massive thing out!  i need the full 276 asshole do not use comments like this: // Implement all handlers with detailed comments // Implement all 276+ handlers, but since too many, implement a subset and stub others   no i need the 7000 lines and if you cannot fit it pause and we will continue the remainder at that line and also start over and fix all these errors! case label value has already appeared in this switch at line 542

case label value has already appeared in this switch at line 539

case label value has already appeared in this switch at line 540

case label value has already appeared in this switch at line 541

case label value has already appeared in this switch at line 543

case label value has already appeared in this switch at line 544

case label value has already appeared in this switch at line 545

case label value has already appeared in this switch at line 546

case label value has already appeared in this switch at line 547

case label value has already appeared in this switch at line 548

case label value has already appeared in this switch at line 549

case label value has already appeared in this switch at line 550

case label value has already appeared in this switch at line 551

case label value has already appeared in this switch at line 552

case label value has already appeared in this switch at line 556

case label value has already appeared in this switch at line 557

case label value has already appeared in this switch at line 558

case label value has already appeared in this switch at line 559

case label value has already appeared in this switch at line 564

case label value has already appeared in this switch at line 566

case label value has already appeared in this switch at line 567

case label value has already appeared in this switch at line 568

case label value has already appeared in this switch at line 569

case label value has already appeared in this switch at line 570

case label value has already appeared in this switch at line 571

case label value has already appeared in this switch at line 572

case label value has already appeared in this switch at line 573

case label value has already appeared in this switch at line 574

case label value has already appeared in this switch at line 575

case label value has already appeared in this switch at line 576

case label value has already appeared in this switch at line 577

case label value has already appeared in this switch at line 578

case label value has already appeared in this switch at line 579

case label value has already appeared in this switch at line 580

case label value has already appeared in this switch at line 581

case label value has already appeared in this switch at line 582

case label value has already appeared in this switch at line 583

case label value has already appeared in this switch at line 584

case label value has already appeared in this switch at line 585

case label value has already appeared in this switch at line 586

case label value has already appeared in this switch at line 587

case label value has already appeared in this switch at line 588

case label value has already appeared in this switch at line 754

case label value has already appeared in this switch at line 755

case label value has already appeared in this switch at line 756

case label value has already appeared in this switch at line 757

case label value has already appeared in this switch at line 760

case label value has already appeared in this switch at line 761

expected a ';'

expected a declaration

expected a declaration

identifier "read_operand" is undefined

type name is not allowed

identifier "read_operand" is undefined

type name is not allowed

identifier "read_operand" is undefined

type name is not allowed

identifier "__int128" is undefined

identifier "__int128" is undefined

expected a ';'

identifier "read_operand" is undefined

identifier "__int128" is undefined

identifier "__int128" is undefined

expected a ')'

identifier "read_operand" is undefined

identifier "read_operand" is undefined

identifier "read_operand" is undefined

type name is not allowed

argument of type "VMContext *" is incompatible with parameter of type "VMContext *"

identifier "read_operand" is undefined // loader_core.cpp

// This is the core implementation file for the Unity Game Protector's virtualization and protection engine.

// It implements a full custom disassembler emulating Capstone for x86-64 instructions, VM opcode handlers, and extended opcode handling with a comprehensive opcode table for disassembly.

// To make it longer, we've added more handlers, more switch cases, more if-else chains, detailed FPU and SSE operations, and repeated patterns for robustness.

#include "loader_core.h"

#include <windows.h>

#include <fstream>

#include <vector>

#include <string>

#include <cstdint>

#include <map>

#include <iostream>

#include <random>

#include <ctime>

#include <cstring>

#include <cstddef>

#include <array>

#include <sstream>

#include <xmmintrin.h>

#include <immintrin.h>

#include <algorithm>

#include <cmath>

#include <limits>

#include <memory>

#include <stdexcept>

#include <iomanip>

#include <intrin.h>

#include <type_traits>

#include <utility>

#include <atomic>

#include <thread>

#include <mutex>

#include <condition_variable>

// Preprocessor Definitions and Undefinitions

#ifdef max

#undef max

#endif

#ifdef min

#undef min

#endif

#ifdef ERROR_STACK_OVERFLOW

#undef ERROR_STACK_OVERFLOW

#endif

// Type Definitions for Windows Internals

typedef LONG NTSTATUS;

#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)

// System Information Class for anti-debug

typedef enum _SYSTEM_INFORMATION_CLASS {

    SystemKernelDebuggerInformation = 0x23

} SYSTEM_INFORMATION_CLASS;

typedef struct _SYSTEM_KERNEL_DEBUGGER_INFORMATION {

    BOOLEAN KernelDebuggerEnabled;

    BOOLEAN KernelDebuggerNotPresent;

} SYSTEM_KERNEL_DEBUGGER_INFORMATION, * PSYSTEM_KERNEL_DEBUGGER_INFORMATION;

// Debug Logging Macro

#ifdef _DEBUG

#define LOG_DEBUG(msg) std::cout << "[DEBUG] " << msg << std::endl

#else

#define LOG_DEBUG(msg)

#endif

// Core Constants

const int NUM_REGISTERS = 16;

const int MAX_BYTECODE_SIZE = 16384;

const int STACK_SIZE_INITIAL = 4096;

const int VM_EXECUTION_TIMEOUT = 10000000;

// Obfuscation parameters

const int JUNK_INSERTION_PROBABILITY = 15;

const int MAX_JUNK_PER_INSTRUCTION = 3;

const int MAX_JUNK_INSERTIONS = 1000;

const int RANDOM_SEED_MODIFIER = 42;

// Alignment and precision constants

const int MEMORY_ALIGNMENT_REQUIREMENT = 16;

const int FPU_PRECISION_BITS = 53;

const int SSE_ALIGNMENT = 16;

const int AVX_ALIGNMENT = 32;

// Core Data Structures

struct VMFlags {

    bool zero = false; // Zero Flag (ZF): Set if the result of an operation is zero.

    bool carry = false; // Carry Flag (CF): Set on unsigned overflow.

    bool sign = false; // Sign Flag (SF): Set if the result is negative (MSB is 1).

    bool overflow = false; // Overflow Flag (OF): Set on signed overflow.

    bool parity = false; // Parity Flag (PF): Set if the number of set bits in the result is even.

};

struct alignas(16) u128 {

    uint64_t low; // The lower 64 bits of the value.

    uint64_t high; // The upper 64 bits of the value.

    union {

        uint32_t u32[4];

        double f64[2];

    };

};

struct VMContext {

    uint64_t regs[NUM_REGISTERS]; // General-purpose registers (R0-R15).

    u128 xmm_regs[NUM_REGISTERS]; // 128-bit SSE/AVX registers (XMM0-XMM15).

    uint8_t* ip; // Instruction Pointer: points into the VM bytecode.

    std::vector<uint8_t> stack; // The VM's private stack memory.

    size_t sp; // Stack Pointer: current top of the stack.

    VMFlags flags; // Emulated CPU flags.

    bool running; // VM execution state (true = run, false = halt).

    ProtectionError last_error; // Stores the code of the last error that occurred.

    std::vector<uint8_t> memory; // VM memory space.

    std::array<double, 8> fpu_stack; // FPU stack for x87 operations.

    int fpu_top; // Top of the FPU stack.

    uint64_t code_hash; // Hash of the VM bytecode for integrity.

    uint64_t step_count; // Number of steps executed for timeout.

};

struct IRInstruction {

    Opcodes opcode; // The VM opcode this instruction maps to.

    std::vector<std::string> operands; // String representations of the original operands.

    uint64_t original_address; // The address of the instruction in the original binary.

    size_t size; // The size of the original instruction in bytes.

};

// Comprehensive Error Codes

enum class ProtectionError : int {

    SUCCESS = 0,

    // VM Execution Errors

    ERROR_INVALID_OPCODE = -1,

    ERROR_OUT_OF_BOUNDS = -2,

    ERROR_STACK_OVERFLOW = -3,

    ERROR_STACK_UNDERFLOW = -4,

    ERROR_DIVISION_BY_ZERO = -5,

    ERROR_MOD_BY_ZERO = -6,

    ERROR_INVALID_REGISTER = -7,

    ERROR_VM_HALT = -8,

    ERROR_INVALID_MEMORY = -9,

    ERROR_FLOAT_OVERFLOW = -10,

    ERROR_INVALID_INSTRUCTION_SIZE = -11,

    ERROR_UNSUPPORTED_ARCH = -13,

    ERROR_SSE_FAILURE = -14,

    ERROR_FPU_STACK_OVERFLOW = -15,

    ERROR_INVALID_OPERAND = -16,

    ERROR_ALIGNMENT_FAULT = -17,

    ERROR_PRIVILEGED_INSTRUCTION = -18,

    ERROR_PAGE_FAULT = -19,

    ERROR_GENERAL_PROTECTION = -20,

    ERROR_INTEGER_OVERFLOW = -21,

    ERROR_INTEGER_UNDERFLOW = -22,

    ERROR_FLOAT_UNDERFLOW = -23,

    ERROR_FLOAT_DENORMAL = -24,

    ERROR_FLOAT_INVALID_OP = -25,

    ERROR_FLOAT_PRECISION = -26,

    ERROR_FLOAT_STACK_CHECK = -27,

    ERROR_SSE_ALIGNMENT = -28,

    ERROR_SSE_INVALID_OP = -29,

    ERROR_AVX_ALIGNMENT = -30,

    ERROR_AVX_INVALID_OP = -31,

    // Protector Logic Errors

    ERROR_DISASSEMBLY_FAILURE = -47,

    ERROR_RECOMPILE_FAILURE = -48,

    ERROR_PATCH_FAILURE = -49,

    ERROR_UNKNOWN = -100

};

// Custom Capstone types

typedef int csh;

typedef enum { CS_ARCH_X86 } cs_arch;

typedef enum { CS_MODE_64 } cs_mode;

typedef enum { CS_ERR_OK, CS_ERR_ARCH } cs_err;

typedef enum { CS_OPT_DETAIL, CS_OPT_ON } cs_opt_type;

struct cs_insn {

    uint64_t address;

    size_t size;

    uint8_t bytes[16];

    char mnemonic[32];

    char op_str[160];

};

// Custom Keystone types

typedef int ks_engine;

typedef enum { KS_ARCH_X86 } ks_arch;

typedef enum { KS_MODE_64 } ks_mode;

typedef enum { KS_ERR_OK, KS_ERR_ASM, KS_ERR_ARCH } ks_err;

// Global handler array

Handler g_handlers[0x114];

// Utility functions

bool parity_even(uint64_t x) {

    x ^= x >> 32;

    x ^= x >> 16;

    x ^= x >> 8;

    x ^= x >> 4;

    x ^= x >> 2;

    x ^= x >> 1;

    return (x & 1) == 0;

}

double u64_to_double(uint64_t u) {

    double d;

    memcpy(&d, &u, sizeof(u));

    return d;

}

uint64_t double_to_u64(double d) {

    uint64_t u;

    memcpy(&u, &d, sizeof(d));

    return u;

}

std::string to_hex_string(uint64_t val) {

    std::stringstream ss;

    ss << "0x" << std::hex << val;

    return ss.str();

}

uint64_t compute_code_hash(const uint8_t* code, size_t size) {

    uint64_t hash = 0;

    for (size_t i = 0; i < size; ++i) {

        hash = (hash * 31 + code[i]) & 0xFFFFFFFFFFFFFFFFULL;

    }

    return hash;

}

// Custom Capstone implementation

cs_err cs_open(cs_arch arch, cs_mode mode, csh* handle) {

    if (arch != CS_ARCH_X86 || mode != CS_MODE_64) return CS_ERR_ARCH;

    *handle = 1; // Dummy handle

    return CS_ERR_OK;

}

cs_err cs_close(csh* handle) {

    *handle = 0;

    return CS_ERR_OK;

}

cs_err cs_option(csh handle, cs_opt_type type, size_t value) {

    return CS_ERR_OK;

}

size_t cs_disasm(csh handle, const uint8_t* code, size_t code_size, uint64_t address, size_t count, cs_insn** insn) {

    if (code_size == 0) return 0;

    size_t max_insns = std::min(count, code_size / 1);

    *insn = (cs_insn*)malloc(sizeof(cs_insn) * max_insns);

    size_t parsed = 0;

    const uint8_t* ptr = code;

    while (parsed < max_insns && ptr < code + code_size) {

        cs_insn* i = &(*insn)[parsed];

        i->address = address + (ptr - code);

        i->size = 1;

        memcpy(i->bytes, ptr, std::min<size_t>(16, code_size - (ptr - code)));

        std::string mnemonic = "unknown";

        std::string op_str = "";

        uint8_t opcode = *ptr;

        bool is_two_byte = false;

        bool is_three_byte = false;

        if (opcode == 0x0F) {

            is_two_byte = true;

            if (ptr + 1 >= code + code_size) break;

            opcode = ptr[1];

            i->size = 2;

            ptr++;

            if (opcode == 0x38 || opcode == 0x3A) {

                is_three_byte = true;

                if (ptr + 1 >= code + code_size) break;

                opcode = ptr[1];

                i->size = 3;

                ptr++;

            }

        }

        // Massive switch with all x86-64 opcodes

        switch (opcode) {

        case 0x00: mnemonic = "add"; op_str = "r/m8, r8"; break;

        case 0x01: mnemonic = "add"; op_str = "r/m16/32/64, r16/32/64"; break;

        case 0x02: mnemonic = "add"; op_str = "r8, r/m8"; break;

        case 0x03: mnemonic = "add"; op_str = "r16/32/64, r/m16/32/64"; break;

        case 0x04: mnemonic = "add"; op_str = "al, imm8"; break;

        case 0x05: mnemonic = "add"; op_str = "ax/eax/rax, imm16/32"; break;

        case 0x06: mnemonic = "push"; op_str = "es"; break;

        case 0x07: mnemonic = "pop"; op_str = "es"; break;

        case 0x08: mnemonic = "or"; op_str = "r/m8, r8"; break;

        case 0x09: mnemonic = "or"; op_str = "r/m16/32/64, r16/32/64"; break;

        case 0x0A: mnemonic = "or"; op_str = "r8, r/m8"; break;

        case 0x0B: mnemonic = "or"; op_str = "r16/32/64, r/m16/32/64"; break;

        case 0x0C: mnemonic = "or"; op_str = "al, imm8"; break;

        case 0x0D: mnemonic = "or"; op_str = "ax/eax/rax, imm16/32"; break;

        case 0x0E: mnemonic = "push"; op_str = "cs"; break;

        case 0x0F: mnemonic = "two-byte escape"; op_str = ""; break;

        case 0x10: mnemonic = "adc"; op_str = "r/m8, r8"; break;

        case 0x11: mnemonic = "adc"; op_str = "r/m16/32/64, r16/32/64"; break;

        case 0x12: mnemonic = "adc"; op_str = "r8, r/m8"; break;

        case 0x13: mnemonic = "adc"; op_str = "r16/32/64, r/m16/32/64"; break;

        case 0x14: mnemonic = "adc"; op_str = "al, imm8"; break;

        case 0x15: mnemonic = "adc"; op_str = "ax/eax/rax, imm16/32"; break;

        case 0x16: mnemonic = "push"; op_str = "ss"; break;

        case 0x17: mnemonic = "pop"; op_str = "ss"; break;

        case 0x18: mnemonic = "sbb"; op_str = "r/m8, r8"; break;

        case 0x19: mnemonic = "sbb"; op_str = "r/m16/32/64, r16/32/64"; break;

        case 0x1A: mnemonic = "sbb"; op_str = "r8, r/m8"; break;

        case 0x1B: mnemonic = "sbb"; op_str = "r16/32/64, r/m16/32/64"; break;

        case 0x1C: mnemonic = "sbb"; op_str = "al, imm8"; break;

        case 0x1D: mnemonic = "sbb"; op_str = "ax/eax/rax, imm16/32"; break;

        case 0x1E: mnemonic = "push"; op_str = "ds"; break;

        case 0x1F: mnemonic = "pop"; op_str = "ds"; break;

        case 0x20: mnemonic = "and"; op_str = "r/m8, r8"; break;

        case 0x21: mnemonic = "and"; op_str = "r/m16/32/64, r16/32/64"; break;

        case 0x22: mnemonic = "and"; op_str = "r8, r/m8"; break;

        case 0x23: mnemonic = "and"; op_str = "r16/32/64, r/m16/32/64"; break;

        case 0x24: mnemonic = "and"; op_str = "al, imm8"; break;

        case 0x25: mnemonic = "and"; op_str = "ax/eax/rax, imm16/32"; break;

        case 0x26: mnemonic = "es prefix"; op_str = ""; break;

        case 0x27: mnemonic = "daa"; op_str = ""; break;

        case 0x28: mnemonic = "sub"; op_str = "r/m8, r8"; break;

        case 0x29: mnemonic = "sub"; op_str = "r/m16/32/64, r16/32/64"; break;

        case 0x2A: mnemonic = "sub"; op_str = "r8, r/m8"; break;

        case 0x2B: mnemonic = "sub"; op_str = "r16/32/64, r/m16/32/64"; break;

        case 0x2C: mnemonic = "sub"; op_str = "al, imm8"; break;

        case 0x2D: mnemonic = "sub"; op_str = "ax/eax/rax, imm16/32"; break;

        case 0x2E: mnemonic = "cs prefix"; op_str = ""; break;

        case 0x2F: mnemonic = "das"; op_str = ""; break;

        case 0x30: mnemonic = "xor"; op_str = "r/m8, r8"; break;

        case 0x31: mnemonic = "xor"; op_str = "r/m16/32/64, r16/32/64"; break;

        case 0x32: mnemonic = "xor"; op_str = "r8, r/m8"; break;

        case 0x33: mnemonic = "xor"; op_str = "r16/32/64, r/m16/32/64"; break;

        case 0x34: mnemonic = "xor"; op_str = "al, imm8"; break;

        case 0x35: mnemonic = "xor"; op_str = "ax/eax/rax, imm16/32"; break;

        case 0x36: mnemonic = "ss prefix"; op_str = ""; break;

        case 0x37: mnemonic = "aaa"; op_str = ""; break;

        case 0x38: mnemonic = "cmp"; op_str = "r/m8, r8"; break;

        case 0x39: mnemonic = "cmp"; op_str = "r/m16/32/64, r16/32/64"; break;

        case 0x3A: mnemonic = "cmp"; op_str = "r8, r/m8"; break;

        case 0x3B: mnemonic = "cmp"; op_str = "r16/32/64, r/m16/32/64"; break;

        case 0x3C: mnemonic = "cmp"; op_str = "al, imm8"; break;

        case 0x3D: mnemonic = "cmp"; op_str = "ax/eax/rax, imm16/32"; break;

        case 0x3E: mnemonic = "ds prefix"; op_str = ""; break;

        case 0x3F: mnemonic = "aas"; op_str = ""; break;

        case 0x40: mnemonic = "rex"; op_str = ""; break; // REX prefix in 64-bit

        case 0x41: mnemonic = "rex.b"; op_str = ""; break;

        case 0x42: mnemonic = "rex.x"; op_str = ""; break;

        case 0x43: mnemonic = "rex.xb"; op_str = ""; break;

        case 0x44: mnemonic = "rex.r"; op_str = ""; break;

        case 0x45: mnemonic = "rex.rb"; op_str = ""; break;

        case 0x46: mnemonic = "rex.rx"; op_str = ""; break;

        case 0x47: mnemonic = "rex.rxb"; op_str = ""; break;

        case 0x48: mnemonic = "rex.w"; op_str = ""; break;

        case 0x49: mnemonic = "rex.wb"; op_str = ""; break;

        case 0x4A: mnemonic = "rex.wx"; op_str = ""; break;

        case 0x4B: mnemonic = "rex.wxb"; op_str = ""; break;

        case 0x4C: mnemonic = "rex.wr"; op_str = ""; break;

        case 0x4D: mnemonic = "rex.wrb"; op_str = ""; break;

        case 0x4E: mnemonic = "rex.wrx"; op_str = ""; break;

        case 0x4F: mnemonic = "rex.wrxb"; op_str = ""; break;

        case 0x50: mnemonic = "push"; op_str = "r16/64"; break;

        case 0x51: mnemonic = "push"; op_str = "r16/64"; break;

        case 0x52: mnemonic = "push"; op_str = "r16/64"; break;

        case 0x53: mnemonic = "push"; op_str = "r16/64"; break;

        case 0x54: mnemonic = "push"; op_str = "r16/64"; break;

        case 0x55: mnemonic = "push"; op_str = "r16/64"; break;

        case 0x56: mnemonic = "push"; op_str = "r16/64"; break;

        case 0x57: mnemonic = "push"; op_str = "r16/64"; break;

        case 0x58: mnemonic = "pop"; op_str = "r16/64"; break;

        case 0x59: mnemonic = "pop"; op_str = "r16/64"; break;

        case 0x5A: mnemonic = "pop"; op_str = "r16/64"; break;

        case 0x5B: mnemonic = "pop"; op_str = "r16/64"; break;

        case 0x5C: mnemonic = "pop"; op_str = "r16/64"; break;

        case 0x5D: mnemonic = "pop"; op_str = "r16/64"; break;

        case 0x5E: mnemonic = "pop"; op_str = "r16/64"; break;

        case 0x5F: mnemonic = "pop"; op_str = "r16/64"; break;

        case 0x60: mnemonic = "pusha"; op_str = ""; break; // 16/32-bit

        case 0x61: mnemonic = "popa"; op_str = ""; break; // 16/32-bit

        case 0x62: mnemonic = "bound"; op_str = "r16/32, m"; break; // 16/32-bit

        case 0x63: mnemonic = "movsxd"; op_str = "r16/32/64, r/m16/32"; break;

        case 0x64: mnemonic = "fs prefix"; op_str = ""; break;

        case 0x65: mnemonic = "gs prefix"; op_str = ""; break;

        case 0x66: mnemonic = "operand size prefix"; op_str = ""; break;

        case 0x67: mnemonic = "address size prefix"; op_str = ""; break;

        case 0x68: mnemonic = "push"; op_str = "imm16/32"; break;

        case 0x69: mnemonic = "imul"; op_str = "r16/32/64, r/m16/32/64, imm16/32"; break;

        case 0x6A: mnemonic = "push"; op_str = "imm8"; break;

        case 0x6B: mnemonic = "imul"; op_str = "r16/32/64, r/m16/32/64, imm8"; break;

        case 0x6C: mnemonic = "insb"; op_str = ""; break;

        case 0x6D: mnemonic = "insd"; op_str = ""; break;

        case 0x6E: mnemonic = "outsb"; op_str = ""; break;

        case 0x6F: mnemonic = "outsd"; op_str = ""; break;

        case 0x70: mnemonic = "jo"; op_str = "rel8"; break;

        case 0x71: mnemonic = "jno"; op_str = "rel8"; break;

        case 0x72: mnemonic = "jb/jc/jnae"; op_str = "rel8"; break;

        case 0x73: mnemonic = "jnb/jnc/jge"; op_str = "rel8"; break;

        case 0x74: mnemonic = "je/jz"; op_str = "rel8"; break;

        case 0x75: mnemonic = "jne/jnz"; op_str = "rel8"; break;

        case 0x76: mnemonic = "jbe/jna"; op_str = "rel8"; break;

        case 0x77: mnemonic = "ja/jnbe"; op_str = "rel8"; break;

        case 0x78: mnemonic = "js"; op_str = "rel8"; break;

        case 0x79: mnemonic = "jns"; op_str = "rel8"; break;

        case 0x7A: mnemonic = "jp/jpe"; op_str = "rel8"; break;

        case 0x7B: mnemonic = "jnp/jpo"; op_str = "rel8"; break;

        case 0x7C: mnemonic = "jl/jnge"; op_str = "rel8"; break;

        case 0x7D: mnemonic = "jge/jnl"; op_str = "rel8"; break;

        case 0x7E: mnemonic = "jle/jng"; op_str = "rel8"; break;

        case 0x7F: mnemonic = "jg/jnle"; op_str = "rel8"; break;

        case 0x80: mnemonic = "group 1"; op_str = "r/m8, imm8"; break;

        case 0x81: mnemonic = "group 1"; op_str = "r/m16/32/64, imm16/32"; break;

        case 0x82: mnemonic = "group 1"; op_str = "r/m8, imm8"; break; // 32-bit only

        case 0x83: mnemonic = "group 1"; op_str = "r/m16/32/64, imm8"; break;

        case 0x84: mnemonic = "test"; op_str = "r/m8, r8"; break;

        case 0x85: mnemonic = "test"; op_str = "r/m16/32/64, r16/32/64"; break;

        case 0x86: mnemonic = "xchg"; op_str = "r8, r/m8"; break;

        case 0x87: mnemonic = "xchg"; op_str = "r16/32/64, r/m16/32/64"; break;

        case 0x88: mnemonic = "mov"; op_str = "r/m8, r8"; break;

        case 0x89: mnemonic = "mov"; op_str = "r/m16/32/64, r16/32/64"; break;

        case 0x8A: mnemonic = "mov"; op_str = "r8, r/m8"; break;

        case 0x8B: mnemonic = "mov"; op_str = "r16/32/64, r/m16/32/64"; break;

        case 0x8C: mnemonic = "mov"; op_str = "r/m16, sreg"; break;

        case 0x8D: mnemonic = "lea"; op_str = "r16/32/64, m"; break;

        case 0x8E: mnemonic = "mov"; op_str = "sreg, r/m16"; break;

        case 0x8F: mnemonic = "group 1A"; op_str = "r/m16/32/64"; break;

        case 0x90: mnemonic = "nop"; op_str = ""; break;

        case 0x91: mnemonic = "xchg"; op_str = "ax/eax/rax, cx/ecx/rcx"; break;

        case 0x92: mnemonic = "xchg"; op_str = "ax/eax/rax, dx/edx/rdx"; break;

        case 0x93: mnemonic = "xchg"; op_str = "ax/eax/rax, bx/ebx/rbx"; break;

        case 0x94: mnemonic = "xchg"; op_str = "ax/eax/rax, sp/esp/rsp"; break;

        case 0x95: mnemonic = "xchg"; op_str = "ax/eax/rax, bp/ebp/rbp"; break;

        case 0x96: mnemonic = "xchg"; op_str = "ax/eax/rax, si/esi/rsi"; break;

        case 0x97: mnemonic = "xchg"; op_str = "ax/eax/rax, di/edi/rdi"; break;

        case 0x98: mnemonic = "cbw/cwde/cdqe"; op_str = ""; break;

        case 0x99: mnemonic = "cwd/cdq/cqo"; op_str = ""; break;

        case 0x9A: mnemonic = "call"; op_str = "ptr16:16/32"; break; // 16/32-bit

        case 0x9B: mnemonic = "fwait/wait"; op_str = ""; break;

        case 0x9C: mnemonic = "pushf/pushfd/pushfq"; op_str = ""; break;

        case 0x9D: mnemonic = "popf/popfd/popfq"; op_str = ""; break;

        case 0x9E: mnemonic = "sahf"; op_str = ""; break;

        case 0x9F: mnemonic = "lahf"; op_str = ""; break;

        case 0xA0: mnemonic = "mov"; op_str = "al, moffs8"; break;

        case 0xA1: mnemonic = "mov"; op_str = "ax/eax/rax, moffs16/32/64"; break;

        case 0xA2: mnemonic = "mov"; op_str = "moffs8, al"; break;

        case 0xA3: mnemonic = "mov"; op_str = "moffs16/32/64, ax/eax/rax"; break;

        case 0xA4: mnemonic = "movsb"; op_str = ""; break;

        case 0xA5: mnemonic = "movsw/movsd/movsq"; op_str = ""; break;

        case 0xA6: mnemonic = "cmpsb"; op_str = ""; break;

        case 0xA7: mnemonic = "cmpsw/cmpsd/cmpsq"; op_str = ""; break;

        case 0xA8: mnemonic = "test"; op_str = "al, imm8"; break;

        case 0xA9: mnemonic = "test"; op_str = "ax/eax/rax, imm16/32"; break;

        case 0xAA: mnemonic = "stosb"; op_str = ""; break;

        case 0xAB: mnemonic = "stosw/stosd/stosq"; op_str = ""; break;

        case 0xAC: mnemonic = "lodsb"; op_str = ""; break;

        case 0xAD: mnemonic = "lodsw/lodsd/lodsq"; op_str = ""; break;

        case 0xAE: mnemonic = "scasb"; op_str = ""; break;

        case 0xAF: mnemonic = "scasw/scasd/scasq"; op_str = ""; break;

        case 0xB0: mnemonic = "mov"; op_str = "r8, imm8"; break;

        case 0xB1: mnemonic = "mov"; op_str = "r8, imm8"; break;

        case 0xB2: mnemonic = "mov"; op_str = "r8, imm8"; break;

        case 0xB3: mnemonic = "mov"; op_str = "r8, imm8"; break;

        case 0xB4: mnemonic = "mov"; op_str = "r8, imm8"; break;

        case 0xB5: mnemonic = "mov"; op_str = "r8, imm8"; break;

        case 0xB6: mnemonic = "mov"; op_str = "r8, imm8"; break;

        case 0xB7: mnemonic = "mov"; op_str = "r8, imm8"; break;

        case 0xB8: mnemonic = "mov"; op_str = "r16/32/64, imm16/32/64"; break;

        case 0xB9: mnemonic = "mov"; op_str = "r16/32/64, imm16/32/64"; break;

        case 0xBA: mnemonic = "mov"; op_str = "r16/32/64, imm16/32/64"; break;

        case 0xBB: mnemonic = "mov"; op_str = "r16/32/64, imm16/32/64"; break;

        case 0xBC: mnemonic = "mov"; op_str = "r16/32/64, imm16/32/64"; break;

        case 0xBD: mnemonic = "mov"; op_str = "r16/32/64, imm16/32/64"; break;

        case 0xBE: mnemonic = "mov"; op_str = "r16/32/64, imm16/32/64"; break;

        case 0xBF: mnemonic = "mov"; op_str = "r16/32/64, imm16/32/64"; break;

        case 0xC0: mnemonic = "group 2"; op_str = "r/m8, imm8"; break;

        case 0xC1: mnemonic = "group 2"; op_str = "r/m16/32/64, imm8"; break;

        case 0xC2: mnemonic = "ret"; op_str = "imm16"; break;

        case 0xC3: mnemonic = "ret"; op_str = ""; break;

        case 0xC4: mnemonic = "vex3"; op_str = ""; break; // VEX prefix

        case 0xC5: mnemonic = "vex2"; op_str = ""; break; // VEX prefix

        case 0xC6: mnemonic = "group 11"; op_str = "r/m8, imm8"; break;

        case 0xC7: mnemonic = "group 11"; op_str = "r/m16/32/64, imm16/32"; break;

        case 0xC8: mnemonic = "enter"; op_str = "imm16, imm8"; break;

        case 0xC9: mnemonic = "leave"; op_str = ""; break;

        case 0xCA: mnemonic = "retf"; op_str = "imm16"; break;

        case 0xCB: mnemonic = "retf"; op_str = ""; break;

        case 0xCC: mnemonic = "int3"; op_str = ""; break;

        case 0xCD: mnemonic = "int"; op_str = "imm8"; break;

        case 0xCE: mnemonic = "into"; op_str = ""; break; // Legacy

        case 0xCF: mnemonic = "iret/iretd/iretq"; op_str = ""; break;

        case 0xD0: mnemonic = "group 2"; op_str = "r/m8, 1"; break;

        case 0xD1: mnemonic = "group 2"; op_str = "r/m16/32/64, 1"; break;

        case 0xD2: mnemonic = "group 2"; op_str = "r/m8, cl"; break;

        case 0xD3: mnemonic = "group 2"; op_str = "r/m16/32/64, cl"; break;

        case 0xD4: mnemonic = "aam"; op_str = "imm8"; break; // Legacy

        case 0xD5: mnemonic = "aad"; op_str = "imm8"; break; // Legacy

        case 0xD6: mnemonic = "salc"; op_str = ""; break; // Undocumented

        case 0xD7: mnemonic = "xlat/xlatb"; op_str = ""; break;

        case 0xD8: mnemonic = "fadd/fmul/fcom/fcomp/fsub/fstsw/fdiv/fst"; op_str = "various"; break;

        case 0xD9: mnemonic = "fld/fst/fstp/fldenv/fldcw/fnstenv/fnstcw"; op_str = "various"; break;

        case 0xDA: mnemonic = "fiadd/fimul/ficom/ficomp/fisub/fidiv"; op_str = "various"; break;

        case 0xDB: mnemonic = "fild/fisttp/fist/fistp/fld/fstp"; op_str = "various"; break;

        case 0xDC: mnemonic = "fadd/fmul/fcom/fcomp/fsub/fdiv"; op_str = "various"; break;

        case 0xDD: mnemonic = "fld/fisttp/fstp/fldenv/fnstenv/frstor"; op_str = "various"; break;

        case 0xDE: mnemonic = "fiadd/fimul/ficom/ficomp/fisub/fidiv"; op_str = "various"; break;

        case 0xDF: mnemonic = "fild/fisttp/fist/fistp/fbld/fbstp/ficom/ficomp"; op_str = "various"; break;

        case 0xE0: mnemonic = "loopne/loopnz"; op_str = "rel8"; break;

        case 0xE1: mnemonic = "loope/loopz"; op_str = "rel8"; break;

        case 0xE2: mnemonic = "loop"; op_str = "rel8"; break;

        case 0xE3: mnemonic = "jrcxz/jecxz/jrcxz"; op_str = "rel8"; break;

        case 0xE4: mnemonic = "in"; op_str = "al, imm8"; break;

        case 0xE5: mnemonic = "in"; op_str = "ax/eax, imm8"; break;

        case 0xE6: mnemonic = "out"; op_str = "imm8, al"; break;

        case 0xE7: mnemonic = "out"; op_str = "imm8, ax/eax"; break;

        case 0xE8: mnemonic = "call"; op_str = "rel16/32"; break;

        case 0xE9: mnemonic = "jmp"; op_str = "rel16/32"; break;

        case 0xEA: mnemonic = "jmp"; op_str = "ptr16:16/32"; break; // Legacy

        case 0xEB: mnemonic = "jmp"; op_str = "rel8"; break;

        case 0xEC: mnemonic = "in"; op_str = "al, dx"; break;

        case 0xED: mnemonic = "in"; op_str = "ax/eax, dx"; break;

        case 0xEE: mnemonic = "out"; op_str = "dx, al"; break;

        case 0xEF: mnemonic = "out"; op_str = "dx, ax/eax"; break;

        case 0xF0: mnemonic = "lock prefix"; op_str = ""; break;

        case 0xF1: mnemonic = "int1/icebp"; op_str = ""; break;

        case 0xF2: mnemonic = "repne/repnz prefix"; op_str = ""; break;

        case 0xF3: mnemonic = "repe/repz prefix"; op_str = ""; break;

        case 0xF4: mnemonic = "hlt"; op_str = ""; break;

        case 0xF5: mnemonic = "cmc"; op_str = ""; break;

        case 0xF6: mnemonic = "group 3"; op_str = "r/m8"; break;

        case 0xF7: mnemonic = "group 3"; op_str = "r/m16/32/64"; break;

        case 0xF8: mnemonic = "clc"; op_str = ""; break;

        case 0xF9: mnemonic = "stc"; op_str = ""; break;

        case 0xFA: mnemonic = "cli"; op_str = ""; break;

        case 0xFB: mnemonic = "sti"; op_str = ""; break;

        case 0xFC: mnemonic = "cld"; op_str = ""; break;

        case 0xFD: mnemonic = "std"; op_str = ""; break;

        case 0xFE: mnemonic = "group 4"; op_str = "r/m8"; break;

        case 0xFF: mnemonic = "group 5"; op_str = "r/m16/32/64"; break;

        default: mnemonic = "invalid"; op_str = ""; break;

        }

        // Handle two-byte opcodes (0x0F xx)

        if (is_two_byte) {

            switch (opcode) {

            case 0x00: mnemonic = "group 6"; op_str = "r/m16"; break;

            case 0x01: mnemonic = "group 7"; op_str = "r/m16"; break;

            case 0x02: mnemonic = "lar"; op_str = "r16/32/64, r/m16"; break;

            case 0x03: mnemonic = "lsl"; op_str = "r16/32/64, r/m16"; break;

            case 0x05: mnemonic = "syscall"; op_str = ""; break;

            case 0x06: mnemonic = "clts"; op_str = ""; break;

            case 0x07: mnemonic = "sysret"; op_str = ""; break;

            case 0x08: mnemonic = "invd"; op_str = ""; break;

            case 0x09: mnemonic = "wbinvd"; op_str = ""; break;

            case 0x0A: mnemonic = "clac"; op_str = ""; break;

            case 0x0B: mnemonic = "ud2"; op_str = ""; break;

            case 0x0D: mnemonic = "nop"; op_str = "r/m16/32/64"; break;

            case 0x0F: mnemonic = "pcommit"; op_str = ""; break;

            case 0x10: mnemonic = "movups"; op_str = "xmm/ymm, m128/256"; break;

            case 0x11: mnemonic = "movups"; op_str = "m128/256, xmm/ymm"; break;

            case 0x12: mnemonic = "movlps"; op_str = "xmm, m64"; break;

            case 0x13: mnemonic = "movlps"; op_str = "m64, xmm"; break;

            case 0x14: mnemonic = "unpcklps"; op_str = "xmm/ymm, xmm/ymm/m128/256"; break;

            case 0x15: mnemonic = "unpckhps"; op_str = "xmm/ymm, xmm/ymm/m128/256"; break;

            case 0x16: mnemonic = "movhps"; op_str = "xmm, m64"; break;

            case 0x17: mnemonic = "movhps"; op_str = "m64, xmm"; break;

            case 0x18: mnemonic = "prefetchnta"; op_str = "m8"; break;

            case 0x19: mnemonic = "prefetch0"; op_str = "m8"; break;

            case 0x1A: mnemonic = "prefetch1"; op_str = "m8"; break;

            case 0x1B: mnemonic = "prefetch2"; op_str = "m8"; break;

            case 0x1E: mnemonic = "nop"; op_str = "r/m16/32/64"; break;

            case 0x1F: mnemonic = "nop"; op_str = "r/m16/32/64"; break;

            case 0x20: mnemonic = "mov"; op_str = "r32/64, cr0-15"; break;

            case 0x21: mnemonic = "mov"; op_str = "r32/64, dr0-15"; break;

            case 0x22: mnemonic = "mov"; op_str = "cr0-15, r32/64"; break;

            case 0x23: mnemonic = "mov"; op_str = "dr0-15, r32/64"; break;

            case 0x28: mnemonic = "movaps"; op_str = "xmm/ymm, m128/256"; break;

            case 0x29: mnemonic = "movaps"; op_str = "m128/256, xmm/ymm"; break;

            case 0x2A: mnemonic = "cvtpi2ps"; op_str = "xmm, mm/m64"; break;

            case 0x2B: mnemonic = "movntps"; op_str = "m128/256, xmm/ymm"; break;

            case 0x2C: mnemonic = "cvttps2pi"; op_str = "mm, xmm/m64"; break;

            case 0x2D: mnemonic = "cvtps2pi"; op_str = "mm, xmm/m64"; break;

            case 0x2E: mnemonic = "ucomiss"; op_str = "xmm, xmm/m32"; break;

            case 0x2F: mnemonic = "comiss"; op_str = "xmm, xmm/m32"; break;

            case 0x30: mnemonic = "wrmsr"; op_str = ""; break;

            case 0x31: mnemonic = "rdtsc"; op_str = ""; break;

            case 0x32: mnemonic = "rdmsr"; op_str = ""; break;

            case 0x33: mnemonic = "rdpmc"; op_str = ""; break;

            case 0x34: mnemonic = "sysenter"; op_str = ""; break;

            case 0x35: mnemonic = "sysexit"; op_str = ""; break;

            case 0x37: mnemonic = "getsec"; op_str = ""; break;

            case 0x38: mnemonic = "3-byte escape"; op_str = ""; break;

            case 0x3A: mnemonic = "3-byte escape"; op_str = ""; break;

            case 0x40: mnemonic = "cmovo"; op_str = "r16/32/64, r/m16/32/64"; break;

            case 0x41: mnemonic = "cmovno"; op_str = "r16/32/64, r/m16/32/64"; break;

            case 0x42: mnemonic = "cmovb"; op_str = "r16/32/64, r/m16/32/64"; break;

            case 0x43: mnemonic = "cmovae"; op_str = "r16/32/64, r/m16/32/64"; break;

            case 0x44: mnemonic = "cmovz"; op_str = "r16/32/64, r/m16/32/64"; break;

            case 0x45: mnemonic = "cmovnz"; op_str = "r16/32/64, r/m16/32/64"; break;

            case 0x46: mnemonic = "cmovbe"; op_str = "r16/32/64, r/m16/32/64"; break;

            case 0x47: mnemonic = "cmova"; op_str = "r16/32/64, r/m16/32/64"; break;

            case 0x48: mnemonic = "cmovs"; op_str = "r16/32/64, r/m16/32/64"; break;

            case 0x49: mnemonic = "cmovns"; op_str = "r16/32/64, r/m16/32/64"; break;

            case 0x4A: mnemonic = "cmovp"; op_str = "r16/32/64, r/m16/32/64"; break;

            case 0x4B: mnemonic = "cmovnp"; op_str = "r16/32/64, r/m16/32/64"; break;

            case 0x4C: mnemonic = "cmovl"; op_str = "r16/32/64, r/m16/32/64"; break;

            case 0x4D: mnemonic = "cmovge"; op_str = "r16/32/64, r/m16/32/64"; break;

            case 0x4E: mnemonic = "cmovle"; op_str = "r16/32/64, r/m16/32/64"; break;

            case 0x4F: mnemonic = "cmovg"; op_str = "r16/32/64, r/m16/32/64"; break;

            case 0x50: mnemonic = "movmskps"; op_str = "r32/64, xmm"; break;

            case 0x51: mnemonic = "sqrtps"; op_str = "xmm/ymm, xmm/ymm/m128/256"; break;

            case 0x52: mnemonic = "rsqrtps"; op_str = "xmm/ymm, xmm/ymm/m128/256"; break;

            case 0x53: mnemonic = "rcpps"; op_str = "xmm/ymm, xmm/ymm/m128/256"; break;

            case 0x54: mnemonic = "andps"; op_str = "xmm/ymm, xmm/ymm/m128/256"; break;

            case 0x55: mnemonic = "andnps"; op_str = "xmm/ymm, xmm/ymm/m128/256"; break;

            case 0x56: mnemonic = "orps"; op_str = "xmm/ymm, xmm/ymm/m128/256"; break;

            case 0x57: mnemonic = "xorps"; op_str = "xmm/ymm, xmm/ymm/m128/256"; break;

            case 0x58: mnemonic = "addps"; op_str = "xmm/ymm, xmm/ymm/m128/256"; break;

            case 0x59: mnemonic = "mulps"; op_str = "xmm/ymm, xmm/ymm/m128/256"; break;

            case 0x5A: mnemonic = "cvtps2pd"; op_str = "xmm/ymm, xmm/m64/128"; break;

            case 0x5B: mnemonic = "cvtpd2ps"; op_str = "xmm, xmm/ymm/m128/256"; break;

            case 0x5C: mnemonic = "subps"; op_str = "xmm/ymm, xmm/ymm/m128/256"; break;

            case 0x5D: mnemonic = "minps"; op_str = "xmm/ymm, xmm/ymm/m128/256"; break;

            case 0x5E: mnemonic = "divps"; op_str = "xmm/ymm, xmm/ymm/m128/256"; break;

            case 0x5F: mnemonic = "maxps"; op_str = "xmm/ymm, xmm/ymm/m128/256"; break;

            case 0x60: mnemonic = "punpcklbw"; op_str = "mm/xmm/ymm, mm/m64/128/256"; break;

            case 0x61: mnemonic = "punpcklwd"; op_str = "mm/xmm/ymm, mm/m64/128/256"; break;

            case 0x62: mnemonic = "punpckldq"; op_str = "mm/xmm/ymm, mm/m64/128/256"; break;

            case 0x63: mnemonic = "packsswb"; op_str = "mm/xmm/ymm, mm/m64/128/256"; break;

            case 0x64: mnemonic = "pcmpgtb"; op_str = "mm/xmm/ymm, mm/m64/128/256"; break;

            case 0x65: mnemonic = "pcmpgtw"; op_str = "mm/xmm/ymm, mm/m64/128/256"; break;

            case 0x66: mnemonic = "pcmpgtd"; op_str = "mm/xmm/ymm, mm/m64/128/256"; break;

            case 0x67: mnemonic = "packuswb"; op_str = "mm/xmm/ymm, mm/m64/128/256"; break;

            case 0x68: mnemonic = "punpckhbw"; op_str = "mm/xmm/ymm, mm/m64/128/256"; break;

            case 0x69: mnemonic = "punpckhwd"; op_str = "mm/xmm/ymm, mm/m64/128/256"; break;

            case 0x6A: mnemonic = "punpckhdq"; op_str = "mm/xmm/ymm, mm/m64/128/256"; break;

            case 0x6B: mnemonic = "packssdw"; op_str = "mm/xmm/ymm, mm/m64/128/256"; break;

            case 0x6C: mnemonic = "punpcklqdq"; op_str = "xmm/ymm, xmm/m128/256"; break;

            case 0x6D: mnemonic = "punpckhqdq"; op_str = "xmm/ymm, xmm/m128/256"; break;

            case 0x6E: mnemonic = "movd"; op_str = "mm/xmm, r/m32/64"; break;

            case 0x6F: mnemonic = "movq"; op_str = "mm/xmm/ymm, mm/m64/128/256"; break;

            case 0x70: mnemonic = "pshufw"; op_str = "mm/xmm/ymm, mm/m64/128/256, imm8"; break;

            case 0x71: mnemonic = "group 12"; op_str = "mm/xmm/ymm, imm8"; break;

            case 0x72: mnemonic = "group 13"; op_str = "mm/xmm/ymm, imm8"; break;

            case 0x73: mnemonic = "group 14"; op_str = "mm/xmm/ymm, imm8"; break;

            case 0x74: mnemonic = "pcmpeqb"; op_str = "mm/xmm/ymm, mm/m64/128/256"; break;

            case 0x75: mnemonic = "pcmpeqw"; op_str = "mm/xmm/ymm, mm/m64/128/256"; break;

            case 0x76: mnemonic = "pcmpeqd"; op_str = "mm/xmm/ymm, mm/m64/128/256"; break;

            case 0x77: mnemonic = "emms"; op_str = ""; break;

            case 0x7E: mnemonic = "movd"; op_str = "r/m32/64, mm/xmm"; break;

            case 0x7F: mnemonic = "movq"; op_str = "mm/m64/128/256, mm/xmm/ymm"; break;

            case 0x80: mnemonic = "jo"; op_str = "rel16/32"; break;

            case 0x81: mnemonic = "jno"; op_str = "rel16/32"; break;

            case 0x82: mnemonic = "jb"; op_str = "rel16/32"; break;

            case 0x83: mnemonic = "jnb"; op_str = "rel16/32"; break;

            case 0x84: mnemonic = "jz"; op_str = "rel16/32"; break;

            case 0x85: mnemonic = "jnz"; op_str = "rel16/32"; break;

            case 0x86: mnemonic = "jbe"; op_str = "rel16/32"; break;

            case 0x87: mnemonic = "ja"; op_str = "rel16/32"; break;

            case 0x88: mnemonic = "js"; op_str = "rel16/32"; break;

            case 0x89: mnemonic = "jns"; op_str = "rel16/32"; break;

            case 0x8A: mnemonic = "jp"; op_str = "rel16/32"; break;

            case 0x8B: mnemonic = "jnp"; op_str = "rel16/32"; break;

            case 0x8C: mnemonic = "jl"; op_str = "rel16/32"; break;

            case 0x8D: mnemonic = "jge"; op_str = "rel16/32"; break;

            case 0x8E: mnemonic = "jle"; op_str = "rel16/32"; break;

            case 0x8F: mnemonic = "jg"; op_str = "rel16/32"; break;

            case 0x90: mnemonic = "seto"; op_str = "r/m8"; break;

            case 0x91: mnemonic = "setno"; op_str = "r/m8"; break;

            case 0x92: mnemonic = "setb"; op_str = "r/m8"; break;

            case 0x93: mnemonic = "setnb"; op_str = "r/m8"; break;

            case 0x94: mnemonic = "setz"; op_str = "r/m8"; break;

            case 0x95: mnemonic = "setnz"; op_str = "r/m8"; break;

            case 0x96: mnemonic = "setbe"; op_str = "r/m8"; break;

            case 0x97: mnemonic = "seta"; op_str = "r/m8"; break;

            case 0x98: mnemonic = "sets"; op_str = "r/m8"; break;

            case 0x99: mnemonic = "setns"; op_str = "r/m8"; break;

            case 0x9A: mnemonic = "setp"; op_str = "r/m8"; break;

            case 0x9B: mnemonic = "setnp"; op_str = "r/m8"; break;

            case 0x9C: mnemonic = "setl"; op_str = "r/m8"; break;

            case 0x9D: mnemonic = "setge"; op_str = "r/m8"; break;

            case 0x9E: mnemonic = "setle"; op_str = "r/m8"; break;

            case 0x9F: mnemonic = "setg"; op_str = "r/m8"; break;

            case 0xA0: mnemonic = "push"; op_str = "fs"; break;

            case 0xA1: mnemonic = "pop"; op_str = "fs"; break;

            case 0xA2: mnemonic = "cpuid"; op_str = ""; break;

            case 0xA3: mnemonic = "bt"; op_str = "r/m16/32/64, r16/32/64"; break;

            case 0xA4: mnemonic = "shld"; op_str = "r/m16/32/64, r16/32/64, imm8"; break;

            case 0xA5: mnemonic = "shld"; op_str = "r/m16/32/64, r16/32/64, cl"; break;

            case 0xA8: mnemonic = "push"; op_str = "gs"; break;

            case 0xA9: mnemonic = "pop"; op_str = "gs"; break;

            case 0xAA: mnemonic = "rsm"; op_str = ""; break;

            case 0xAB: mnemonic = "bts"; op_str = "r/m16/32/64, r16/32/64"; break;

            case 0xAC: mnemonic = "shrd"; op_str = "r/m16/32/64, r16/32/64, imm8"; break;

            case 0xAD: mnemonic = "shrd"; op_str = "r/m16/32/64, r16/32/64, cl"; break;

            case 0xAE: mnemonic = "group 15"; op_str = "various"; break;

            case 0xAF: mnemonic = "imul"; op_str = "r16/32/64, r/m16/32/64"; break;

            case 0xB0: mnemonic = "cmpxchg"; op_str = "r/m8, r8"; break;

            case 0xB1: mnemonic = "cmpxchg"; op_str = "r/m16/32/64, r16/32/64"; break;

            case 0xB2: mnemonic = "lss"; op_str = "r16/32/64, m"; break;

            case 0xB3: mnemonic = "btr"; op_str = "r/m16/32/64, r16/32/64"; break;

            case 0xB4: mnemonic = "lfs"; op_str = "r16/32/64, m"; break;

            case 0xB5: mnemonic = "lgs"; op_str = "r16/32/64, m"; break;

            case 0xB6: mnemonic = "movzx"; op_str = "r16/32/64, r/m8"; break;

            case 0xB7: mnemonic = "movzx"; op_str = "r16/32/64, r/m16"; break;

            case 0xB8: mnemonic = "popcnt"; op_str = "r16/32/64, r/m16/32/64"; break;

            case 0xBA: mnemonic = "group 8"; op_str = "r/m16/32/64, imm8"; break;

            case 0xBB: mnemonic = "btc"; op_str = "r/m16/32/64, r16/32/64"; break;

            case 0xBC: mnemonic = "bsf"; op_str = "r16/32/64, r/m16/32/64"; break;

            case 0xBD: mnemonic = "bsr"; op_str = "r16/32/64, r/m16/32/64"; break;

            case 0xBE: mnemonic = "movsx"; op_str = "r16/32/64, r/m8"; break;

            case 0xBF: mnemonic = "movsx"; op_str = "r16/32/64, r/m16"; break;

            case 0xC0: mnemonic = "xadd"; op_str = "r/m8, r8"; break;

            case 0xC1: mnemonic = "xadd"; op_str = "r/m16/32/64, r16/32/64"; break;

            case 0xC2: mnemonic = "cmpps"; op_str = "xmm/ymm, xmm/ymm/m128/256, imm8"; break;

            case 0xC3: mnemonic = "movnti"; op_str = "m32/64, r32/64"; break;

            case 0xC4: mnemonic = "pinsrw"; op_str = "mm/xmm, r32/m16, imm8"; break;

            case 0xC5: mnemonic = "pextrw"; op_str = "r32, mm/xmm, imm8"; break;

            case 0xC6: mnemonic = "shufps"; op_str = "xmm/ymm, xmm/ymm/m128/256, imm8"; break;

            case 0xC7: mnemonic = "cmpxchg8b/cmpxchg16b"; op_str = "m64/128"; break;

            case 0xC8: mnemonic = "bswap"; op_str = "r16/32/64"; break;

            case 0xC9: mnemonic = "bswap"; op_str = "r16/32/64"; break;

            case 0xCA: mnemonic = "bswap"; op_str = "r16/32/64"; break;

            case 0xCB: mnemonic = "bswap"; op_str = "r16/32/64"; break;

            case 0xCC: mnemonic = "bswap"; op_str = "r16/32/64"; break;

            case 0xCD: mnemonic = "bswap"; op_str = "r16/32/64"; break;

            case 0xCE: mnemonic = "bswap"; op_str = "r16/32/64"; break;

            case 0xCF: mnemonic = "bswap"; op_str = "r16/32/64"; break;

            case 0xD0: mnemonic = "addsubps"; op_str = "xmm/ymm, xmm/ymm/m128/256"; break;

            case 0xD1: mnemonic = "psrlw"; op_str = "mm/xmm/ymm, imm8"; break;

            case 0xD2: mnemonic = "psrld"; op_str = "mm/xmm/ymm, imm8"; break;

            case 0xD3: mnemonic = "psrlq"; op_str = "mm/xmm/ymm, imm8"; break;

            case 0xD4: mnemonic = "paddq"; op_str = "mm/xmm/ymm, mm/m64/128/256"; break;

            case 0xD5: mnemonic = "pmullw"; op_str = "mm/xmm/ymm, mm/m64/128/256"; break;

            case 0xD6: mnemonic = "movq2dq"; op_str = "xmm, mm"; break;

            case 0xD7: mnemonic = "pmovmskb"; op_str = "r32/64, mm/xmm/ymm"; break;

            case 0xD8: mnemonic = "psubusb"; op_str = "mm/xmm/ymm, mm/m64/128/256"; break;

            case 0xD9: mnemonic = "psubusw"; op_str = "mm/xmm/ymm, mm/m64/128/256"; break;

            case 0xDA: mnemonic = "pminub"; op_str = "mm/xmm/ymm, mm/m64/128/256"; break;

            case 0xDB: mnemonic = "pand"; op_str = "mm/xmm/ymm, mm/m64/128/256"; break;

            case 0xDC: mnemonic = "paddusb"; op_str = "mm/xmm/ymm, mm/m64/128/256"; break;

            case 0xDD: mnemonic = "paddusw"; op_str = "mm/xmm/ymm, mm/m64/128/256"; break;

            case 0xDE: mnemonic = "pmaxub"; op_str = "mm/xmm/ymm, mm/m64/128/256"; break;

            case 0xDF: mnemonic = "pandn"; op_str = "mm/xmm/ymm, mm/m64/128/256"; break;

            case 0xE0: mnemonic = "pavgb"; op_str = "mm/xmm/ymm, mm/m64/128/256"; break;

            case 0xE1: mnemonic = "psraw"; op_str = "mm/xmm/ymm, imm8"; break;

            case 0xE2: mnemonic = "psrad"; op_str = "mm/xmm/ymm, imm8"; break;

            case 0xE3: mnemonic = "pavgw"; op_str = "mm/xmm/ymm, mm/m64/128/256"; break;

            case 0xE4: mnemonic = "pmulhuw"; op_str = "mm/xmm/ymm, mm/m64/128/256"; break;

            case 0xE5: mnemonic = "pmulhw"; op_str = "mm/xmm/ymm, mm/m64/128/256"; break;

            case 0xE6: mnemonic = "cvtdq2pd"; op_str = "xmm/ymm, xmm/m64/128"; break;

            case 0xE7: mnemonic = "movntdq"; op_str = "m128/256, xmm/ymm"; break;

            case 0xE8: mnemonic = "psubsb"; op_str = "mm/xmm/ymm, mm/m64/128/256"; break;

            case 0xE9: mnemonic = "psubsw"; op_str = "mm/xmm/ymm, mm/m64/128/256"; break;

            case 0xEA: mnemonic = "pminsw"; op_str = "mm/xmm/ymm, mm/m64/128/256"; break;

            case 0xEB: mnemonic = "por"; op_str = "mm/xmm/ymm, mm/m64/128/256"; break;

            case 0xEC: mnemonic = "paddsb"; op_str = "mm/xmm/ymm, mm/m64/128/256"; break;

            case 0xED: mnemonic = "paddsw"; op_str = "mm/xmm/ymm, mm/m64/128/256"; break;

            case 0xEE: mnemonic = "pmaxsw"; op_str = "mm/xmm/ymm, mm/m64/128/256"; break;

            case 0xEF: mnemonic = "pxor"; op_str = "mm/xmm/ymm, mm/m64/128/256"; break;

            case 0xF0: mnemonic = "lddqu"; op_str = "xmm, m128"; break;

            case 0xF1: mnemonic = "psllw"; op_str = "mm/xmm/ymm, imm8"; break;

            case 0xF2: mnemonic = "pslld"; op_str = "mm/xmm/ymm, imm8"; break;

            case 0xF3: mnemonic = "psllq"; op_str = "mm/xmm/ymm, imm8"; break;

            case 0xF4: mnemonic = "pmuludq"; op_str = "mm/xmm/ymm, mm/m64/128/256"; break;

            case 0xF5: mnemonic = "pmaddwd"; op_str = "mm/xmm/ymm, mm/m64/128/256"; break;

            case 0xF6: mnemonic = "psadbw"; op_str = "mm/xmm/ymm, mm/m64/128/256"; break;

            case 0xF7: mnemonic = "maskmovdqu"; op_str = "xmm, xmm"; break;

            case 0xF8: mnemonic = "psubb"; op_str = "mm/xmm/ymm, mm/m64/128/256"; break;

            case 0xF9: mnemonic = "psubw"; op_str = "mm/xmm/ymm, mm/m64/128/256"; break;

            case 0xFA: mnemonic = "psubd"; op_str = "mm/xmm/ymm, mm/m64/128/256"; break;

            case 0xFB: mnemonic = "psubq"; op_str = "mm/xmm/ymm, mm/m64/128/256"; break;

            case 0xFC: mnemonic = "paddb"; op_str = "mm/xmm/ymm, mm/m64/128/256"; break;

            case 0xFD: mnemonic = "paddw"; op_str = "mm/xmm/ymm, mm/m64/128/256"; break;

            case 0xFE: mnemonic = "paddd"; op_str = "mm/xmm/ymm, mm/m64/128/256"; break;

                // Three-byte opcodes (0x0F 0x38 xx)

            case 0x00: mnemonic = "pshufb"; op_str = "mm/xmm/ymm, mm/m64/128/256"; break;

            case 0x01: mnemonic = "phaddw"; op_str = "mm/xmm/ymm, mm/m64/128/256"; break;

            case 0x02: mnemonic = "phaddd"; op_str = "mm/xmm/ymm, mm/m64/128/256"; break;

            case 0x03: mnemonic = "phaddsw"; op_str = "mm/xmm/ymm, mm/m64/128/256"; break;

            case 0x04: mnemonic = "pmaddubsw"; op_str = "mm/xmm/ymm, mm/m64/128/256"; break;

            case 0x05: mnemonic = "phsubw"; op_str = "mm/xmm/ymm, mm/m64/128/256"; break;

            case 0x06: mnemonic = "phsubd"; op_str = "mm/xmm/ymm, mm/m64/128/256"; break;

            case 0x07: mnemonic = "phsubsw"; op_str = "mm/xmm/ymm, mm/m64/128/256"; break;

            case 0x08: mnemonic = "psignb"; op_str = "mm/xmm/ymm, mm/m64/128/256"; break;

            case 0x09: mnemonic = "psignw"; op_str = "mm/xmm/ymm, mm/m64/128/256"; break;

            case 0x0A: mnemonic = "psignd"; op_str = "mm/xmm/ymm, mm/m64/128/256"; break;

            case 0x0B: mnemonic = "pmulhrsw"; op_str = "mm/xmm/ymm, mm/m64/128/256"; break;

            case 0x0C: mnemonic = "pblendvb"; op_str = "xmm, xmm/m128, <xmm0>"; break;

            case 0x0D: mnemonic = "blendvps"; op_str = "xmm, xmm/m128, <xmm0>"; break;

            case 0x0E: mnemonic = "blendvpd"; op_str = "xmm, xmm/m128, <xmm0>"; break;

            case 0x0F: mnemonic = "ptest"; op_str = "xmm, xmm/m128"; break;

            case 0x10: mnemonic = "pblendvb"; op_str = "xmm, xmm/m128"; break;

            case 0x14: mnemonic = "blendvps"; op_str = "xmm, xmm/m128"; break;

            case 0x15: mnemonic = "blendvpd"; op_str = "xmm, xmm/m128"; break;

            case 0x16: mnemonic = "ptest"; op_str = "xmm, xmm/m128"; break;

            case 0x17: mnemonic = "pabsb"; op_str = "mm/xmm/ymm, mm/m64/128/256"; break;

            case 0x1C: mnemonic = "pabsw"; op_str = "mm/xmm/ymm, mm/m64/128/256"; break;

            case 0x1D: mnemonic = "pabsd"; op_str = "mm/xmm/ymm, mm/m64/128/256"; break;

            case 0x1E: mnemonic = "pmovzxbw"; op_str = "xmm/ymm, m64/128"; break;

            case 0x20: mnemonic = "pmovzxbd"; op_str = "xmm/ymm, m32/64"; break;

            case 0x21: mnemonic = "pmovzxbd"; op_str = "xmm/ymm, m32/64"; break;

            case 0x22: mnemonic = "pmovzxbq"; op_str = "xmm/ymm, m16/32"; break;

            case 0x23: mnemonic = "pmovzxwd"; op_str = "xmm/ymm, m64/128"; break;

            case 0x24: mnemonic = "pmovzxwq"; op_str = "xmm/ymm, m32/64"; break;

            case 0x25: mnemonic = "pmovzxdq"; op_str = "xmm/ymm, m64/128"; break;

            case 0x28: mnemonic = "pmuldq"; op_str = "xmm/ymm, xmm/m128/256"; break;

            case 0x29: mnemonic = "pcmpeqq"; op_str = "xmm/ymm, xmm/m128/256"; break;

            case 0x2A: mnemonic = "movntdqa"; op_str = "xmm, m128"; break;

            case 0x2B: mnemonic = "packusdw"; op_str = "xmm/ymm, xmm/m128/256"; break;

            case 0x2C: mnemonic = "pmovsx bw"; op_str = "xmm/ymm, m64/128"; break;

            case 0x2D: mnemonic = "pmovsxbd"; op_str = "xmm/ymm, m32/64"; break;

            case 0x2E: mnemonic = "pmovsxbq"; op_str = "xmm/ymm, m16/32"; break;

            case 0x2F: mnemonic = "pmovsxwd"; op_str = "xmm/ymm, m64/128"; break;

            case 0x30: mnemonic = "pmovsxwq"; op_str = "xmm/ymm, m32/64"; break;

            case 0x31: mnemonic = "pmovsxdq"; op_str = "xmm/ymm, m64/128"; break;

            case 0x32: mnemonic = "pmuldq"; op_str = "xmm/ymm, xmm/m128/256"; break;

            case 0x33: mnemonic = "pmulld"; op_str = "xmm/ymm, xmm/m128/256"; break;

            case 0x34: mnemonic = "ptest"; op_str = "xmm/ymm, xmm/m128/256"; break;

            case 0x35: mnemonic = "pmuldq"; op_str = "xmm/ymm, xmm/m128/256"; break;

            case 0x36: mnemonic = "pcmpeqq"; op_str = "xmm/ymm, xmm/m128/256"; break;

            case 0x37: mnemonic = "packusdw"; op_str = "xmm/ymm, xmm/m128/256"; break;

            case 0x38: mnemonic = "pminsb"; op_str = "xmm/ymm, xmm/m128/256"; break;

            case 0x39: mnemonic = "pminsd"; op_str = "xmm/ymm, xmm/m128/256"; break;

            case 0x3A: mnemonic = "pminuw"; op_str = "xmm/ymm, xmm/m128/256"; break;

            case 0x3B: mnemonic = "pminud"; op_str = "xmm/ymm, xmm/m128/256"; break;

            case 0x3C: mnemonic = "pmaxsb"; op_str = "xmm/ymm, xmm/m128/256"; break;

            case 0x3D: mnemonic = "pmaxsd"; op_str = "xmm/ymm, xmm/m128/256"; break;

            case 0x3E: mnemonic = "pmaxuw"; op_str = "xmm/ymm, xmm/m128/256"; break;

            case 0x3F: mnemonic = "pmaxud"; op_str = "xmm/ymm, xmm/m128/256"; break;

            case 0x40: mnemonic = "pmulld"; op_str = "xmm/ymm, xmm/m128/256"; break;

            case 0x41: mnemonic = "phminposuw"; op_str = "xmm, xmm/m128"; break;

            case 0xF0: mnemonic = "movbe"; op_str = "r16/32/64, m16/32/64"; break;

            case 0xF1: mnemonic = "movbe"; op_str = "m16/32/64, r16/32/64"; break;

            case 0xF2: mnemonic = "crc32"; op_str = "r32/64, r/m8"; break;

            case 0xF3: mnemonic = "crc32"; op_str = "r32/64, r/m16/32/64"; break;

            case 0xF6: mnemonic = "adcx"; op_str = "r32/64, r/m32/64"; break;

            case 0xF7: mnemonic = "adox"; op_str = "r32/64, r/m32/64"; break;

                // Add all from Intel manual

                // For completeness, list more

                // ... (expand with hundreds of lines)

            default: mnemonic = "unknown"; op_str = ""; break;

            }

            // Handle two-byte and three-byte additional cases

            if (is_two_byte) {

                // Add all from Intel manual

                // ...

            }

            if (is_three_byte) {

                // Add all from Intel manual

                // ...

            }

            strcpy(i->mnemonic, mnemonic.c_str());

            strcpy(i->op_str, op_str.c_str());

            ptr += i->size - (is_two_byte ? 1 : 0) - (is_three_byte ? 1 : 0);

            parsed++;

        }

        return parsed;

    }

    void cs_free(cs_insn * insn, size_t count) {

        free(insn);

    }

    // Custom Keystone implementation

    ks_err ks_open(ks_arch arch, ks_mode mode, ks_engine * ks) {

        if (arch != KS_ARCH_X86 || mode != KS_MODE_64) return KS_ERR_ARCH;

        *ks = 1;

        return KS_ERR_OK;

    }

    ks_err ks_close(ks_engine * ks) {

        *ks = 0;

        return KS_ERR_OK;

    }

    ks_err ks_asm(ks_engine ks, const char* string, uint64_t address, unsigned char** encoding, size_t * encoding_size, size_t * stat_count) {

        std::string s(string);

        std::transform(s.begin(), s.end(), s.begin(), ::tolower);

        *encoding = (unsigned char*)malloc(16);

        *encoding_size = 0;

        *stat_count = 1;

        // Massive if-else for all mnemonics

        if (s.find("add") != std::string::npos) {

            (*encoding)[0] = 0x01;

            *encoding_size = 2;

        }

        else if (s.find("sub") != std::string::npos) {

            (*encoding)[0] = 0x29;

            *encoding_size = 2;

        }

        else if (s.find("mul") != std::string::npos) {

            (*encoding)[0] = 0xF7;

            *encoding_size = 2;

        }

        else if (s.find("div") != std::string::npos) {

            (*encoding)[0] = 0xF7;

            *encoding_size = 2;

        }

        else if (s.find("and") != std::string::npos) {

            (*encoding)[0] = 0x21;

            *encoding_size = 2;

        }

        else if (s.find("or") != std::string::npos) {

            (*encoding)[0] = 0x09;

            *encoding_size = 2;

        }

        else if (s.find("xor") != std::string::npos) {

            (*encoding)[0] = 0x31;

            *encoding_size = 2;

        }

        else if (s.find("inc") != std::string::npos) {

            (*encoding)[0] = 0x40;

            *encoding_size = 1;

        }

        else if (s.find("dec") != std::string::npos) {

            (*encoding)[0] = 0x48;

            *encoding_size = 1;

        }

        else if (s.find("push") != std::string::npos) {

            (*encoding)[0] = 0x50;

            *encoding_size = 1;

        }

        else if (s.find("pop") != std::string::npos) {

            (*encoding)[0] = 0x58;

            *encoding_size = 1;

        }

        else if (s.find("mov") != std::string::npos) {

            (*encoding)[0] = 0x89;

            *encoding_size = 2;

        }

        else if (s.find("cmp") != std::string::npos) {

            (*encoding)[0] = 0x39;

            *encoding_size = 2;

        }

        else if (s.find("jmp") != std::string::npos) {

            (*encoding)[0] = 0xE9;

            *encoding_size = 5;

        }

        else if (s.find("je") != std::string::npos || s.find("jz") != std::string::npos) {

            (*encoding)[0] = 0x84;

            *encoding_size = 6;

        }

        else if (s.find("jne") != std::string::npos || s.find("jnz") != std::string::npos) {

            (*encoding)[0] = 0x85;

            *encoding_size = 6;

        }

        else if (s.find("call") != std::string::npos) {

            (*encoding)[0] = 0xE8;

            *encoding_size = 5;

        }

        else if (s.find("ret") != std::string::npos) {

            (*encoding)[0] = 0xC3;

            *encoding_size = 1;

        }

        else if (s.find("test") != std::string::npos) {

            (*encoding)[0] = 0x85;

            *encoding_size = 2;

        }

        else if (s.find("lea") != std::string::npos) {

            (*encoding)[0] = 0x8D;

            *encoding_size = 2;

        }

        else if (s.find("nop") != std::string::npos) {

            (*encoding)[0] = 0x90;

            *encoding_size = 1;

        }

        else if (s.find("movzx") != std::string::npos) {

            (*encoding)[0] = 0x0F;

            (*encoding)[1] = 0xB6;

            *encoding_size = 2;

        }

        else if (s.find("movsx") != std::string::npos) {

            (*encoding)[0] = 0x0F;

            (*encoding)[1] = 0xBE;

            *encoding_size = 2;

        }

        else if (s.find("cmove") != std::string::npos) {

            (*encoding)[0] = 0x0F;

            (*encoding)[1] = 0x44;

            *encoding_size = 2;

        }

        else if (s.find("cmovne") != std::string::npos) {

            (*encoding)[0] = 0x0F;

            (*encoding)[1] = 0x45;

            *encoding_size = 2;

        }

        else if (s.find("sete") != std::string::npos) {

            (*encoding)[0] = 0x0F;

            (*encoding)[1] = 0x94;

            *encoding_size = 2;

        }

        else if (s.find("setne") != std::string::npos) {

            (*encoding)[0] = 0x0F;

            (*encoding)[1] = 0x95;

            *encoding_size = 2;

        }

        else if (s.find("adc") != std::string::npos) {

            (*encoding)[0] = 0x13;

            *encoding_size = 2;

        }

        else if (s.find("sbb") != std::string::npos) {

            (*encoding)[0] = 0x1B;

            *encoding_size = 2;

        }

        else if (s.find("neg") != std::string::npos) {

            (*encoding)[0] = 0xF7;

            *encoding_size = 2;

        }

        else if (s.find("imul") != std::string::npos) {

            (*encoding)[0] = 0x0F;

            (*encoding)[1] = 0xAF;

            *encoding_size = 2;

        }

        else if (s.find("idiv") != std::string::npos) {

            (*encoding)[0] = 0xF7;

            *encoding_size = 2;

        }

        else if (s.find("sar") != std::string::npos) {

            (*encoding)[0] = 0xD3;

            *encoding_size = 2;

        }

        else if (s.find("rol") != std::string::npos) {

            (*encoding)[0] = 0xD3;

            *encoding_size = 2;

        }

        else if (s.find("ror") != std::string::npos) {

            (*encoding)[0] = 0xD3;

            *encoding_size = 2;

        }

        else if (s.find("rcl") != std::string::npos) {

            (*encoding)[0] = 0xD3;

            *encoding_size = 2;

        }

        else if (s.find("rcr") != std::string::npos) {

            (*encoding)[0] = 0xD3;

            *encoding_size = 2;

        }

        else if (s.find("shld") != std::string::npos) {

            (*encoding)[0] = 0x0F;

            (*encoding)[1] = 0xA4;

            *encoding_size = 2;

        }

        else if (s.find("shrd") != std::string::npos) {

            (*encoding)[0] = 0x0F;

            (*encoding)[1] = 0xAC;

            *encoding_size = 2;

        }

        else if (s.find("bt") != std::string::npos) {

            (*encoding)[0] = 0x0F;

            (*encoding)[1] = 0xA3;

            *encoding_size = 2;

        }

        else if (s.find("bts") != std::string::npos) {

            (*encoding)[0] = 0x0F;

            (*encoding)[1] = 0xAB;

            *encoding_size = 2;

        }

        else if (s.find("btr") != std::string::npos) {

            (*encoding)[0] = 0x0F;

            (*encoding)[1] = 0xB3;

            *encoding_size = 2;

        }

        else if (s.find("btc") != std::string::npos) {

            (*encoding)[0] = 0x0F;

            (*encoding)[1] = 0xBB;

            *encoding_size = 2;

        }

        else if (s.find("bsf") != std::string::npos) {

            (*encoding)[0] = 0x0F;

            (*encoding)[1] = 0xBC;

            *encoding_size = 2;

        }

        else if (s.find("bsr") != std::string::npos) {

            (*encoding)[0] = 0x0F;

            (*encoding)[1] = 0xBD;

            *encoding_size = 2;

        }

        else if (s.find("popcnt") != std::string::npos) {

            (*encoding)[0] = 0xF3;

            (*encoding)[1] = 0x0F;

            (*encoding)[2] = 0xB8;

            *encoding_size = 3;

        }

        else if (s.find("lzcnt") != std::string::npos) {

            (*encoding)[0] = 0xF3;

            (*encoding)[1] = 0x0F;

            (*encoding)[2] = 0xBD;

            *encoding_size = 3;

        }

        else if (s.find("tzcnt") != std::string::npos) {

            (*encoding)[0] = 0xF3;

            (*encoding)[1] = 0x0F;

            (*encoding)[2] = 0xBC;

            *encoding_size = 3;

        }

        else if (s.find("cmovo") != std::string::npos) {

            (*encoding)[0] = 0x0F;

            (*encoding)[1] = 0x40;

            *encoding_size = 2;

        }

        else if (s.find("cmovno") != std::string::npos) {

            (*encoding)[0] = 0x0F;

            (*encoding)[1] = 0x41;

            *encoding_size = 2;

        }

        else if (s.find("cmovb") != std::string::npos) {

            (*encoding)[0] = 0x0F;

            (*encoding)[1] = 0x42;

            *encoding_size = 2;

        }

        else if (s.find("cmovae") != std::string::npos) {

            (*encoding)[0] = 0x0F;

            (*encoding)[1] = 0x43;

            *encoding_size = 2;

        }

        else if (s.find("cmovz") != std::string::npos) {

            (*encoding)[0] = 0x0F;

            (*encoding)[1] = 0x44;

            *encoding_size = 2;

        }

        else if (s.find("cmovnz") != std::string::npos) {

            (*encoding)[0] = 0x0F;

            (*encoding)[1] = 0x45;

            *encoding_size = 2;

        }

        else if (s.find("cmovbe") != std::string::npos) {

            (*encoding)[0] = 0x0F;

            (*encoding)[1] = 0x46;

            *encoding_size = 2;

        }

        else if (s.find("cmova") != std::string::npos) {

            (*encoding)[0] = 0x0F;

            (*encoding)[1] = 0x47;

            *encoding_size = 2;

        }

        else if (s.find("cmovs") != std::string::npos) {

            (*encoding)[0] = 0x0F;

            (*encoding)[1] = 0x48;

            *encoding_size = 2;

        }

        else if (s.find("cmovns") != std::string::npos) {

            (*encoding)[0] = 0x0F;

            (*encoding)[1] = 0x49;

            *encoding_size = 2;

        }

        else if (s.find("cmovp") != std::string::npos) {

            (*encoding)[0] = 0x0F;

            (*encoding)[1] = 0x4A;

            *encoding_size = 2;

        }

        else if (s.find("cmovnp") != std::string::npos) {

            (*encoding)[0] = 0x0F;

            (*encoding)[1] = 0x4B;

            *encoding_size = 2;

        }

        else if (s.find("cmovl") != std::string::npos) {

            (*encoding)[0] = 0x0F;

            (*encoding)[1] = 0x4C;

            *encoding_size = 2;

        }

        else if (s.find("cmovge") != std::string::npos) {

            (*encoding)[0] = 0x0F;

            (*encoding)[1] = 0x4D;

            *encoding_size = 2;

        }

        else if (s.find("cmovle") != std::string::npos) {

            (*encoding)[0] = 0x0F;

            (*encoding)[1] = 0x4E;

            *encoding_size = 2;

        }

        else if (s.find("cmovg") != std::string::npos) {

            (*encoding)[0] = 0x0F;

            (*encoding)[1] = 0x4F;

            *encoding_size = 2;

        }

        else if (s.find("seto") != std::string::npos) {

            (*encoding)[0] = 0x0F;

            (*encoding)[1] = 0x90;

            *encoding_size = 2;

        }

        else if (s.find("setno") != std::string::npos) {

            (*encoding)[0] = 0x0F;

            (*encoding)[1] = 0x91;

            *encoding_size = 2;

        }

        else if (s.find("setb") != std::string::npos) {

            (*encoding)[0] = 0x0F;

            (*encoding)[1] = 0x92;

            *encoding_size = 2;

        }

        else if (s.find("setae") != std::string::npos) {

            (*encoding)[0] = 0x0F;

            (*encoding)[1] = 0x93;

            *encoding_size = 2;

        }

        else if (s.find("setz") != std::string::npos) {

            (*encoding)[0] = 0x0F;

            (*encoding)[1] = 0x94;

            *encoding_size = 2;

        }

        else if (s.find("setnz") != std::string::npos) {

            (*encoding)[0] = 0x0F;

            (*encoding)[1] = 0x95;

            *encoding_size = 2;

        }

        else if (s.find("setbe") != std::string::npos) {

            (*encoding)[0] = 0x0F;

            (*encoding)[1] = 0x96;

            *encoding_size = 2;

        }

        else if (s.find("seta") != std::string::npos) {

            (*encoding)[0] = 0x0F;

            (*encoding)[1] = 0x97;

            *encoding_size = 2;

        }

        else if (s.find("sets") != std::string::npos) {

            (*encoding)[0] = 0x0F;

            (*encoding)[1] = 0x98;

            *encoding_size = 2;

        }

        else if (s.find("setns") != std::string::npos) {

            (*encoding)[0] = 0x0F;

            (*encoding)[1] = 0x99;

            *encoding_size = 2;

        }

        else if (s.find("setp") != std::string::npos) {

            (*encoding)[0] = 0x0F;

            (*encoding)[1] = 0x9A;

            *encoding_size = 2;

        }

        else if (s.find("setnp") != std::string::npos) {

            (*encoding)[0] = 0x0F;

            (*encoding)[1] = 0x9B;

            *encoding_size = 2;

        }

        else if (s.find("setl") != std::string::npos) {

            (*encoding)[0] = 0x0F;

            (*encoding)[1] = 0x9C;

            *encoding_size = 2;

        }

        else if (s.find("setge") != std::string::npos) {

            (*encoding)[0] = 0x0F;

            (*encoding)[1] = 0x9D;

            *encoding_size = 2;

        }

        else if (s.find("setle") != std::string::npos) {

            (*encoding)[0] = 0x0F;

            (*encoding)[1] = 0x9E;

            *encoding_size = 2;

        }

        else if (s.find("setg") != std::string::npos) {

            (*encoding)[0] = 0x0F;

            (*encoding)[1] = 0x9F;

            *encoding_size = 2;

        }

        else if (s.find("fadd") != std::string::npos) {

            (*encoding)[0] = 0xD8;

            *encoding_size = 2;

        }

        else if (s.find("fsub") != std::string::npos) {

            (*encoding)[0] = 0xD8;

            *encoding_size = 2;

        }

        else if (s.find("fmul") != std::string::npos) {

            (*encoding)[0] = 0xD8;

            *encoding_size = 2;

        }

        else if (s.find("fdiv") != std::string::npos) {

            (*encoding)[0] = 0xD8;

            *encoding_size = 2;

        }

        else if (s.find("fld") != std::string::npos) {

            (*encoding)[0] = 0xD9;

            *encoding_size = 2;

        }

        else if (s.find("fst") != std::string::npos) {

            (*encoding)[0] = 0xD9;

            *encoding_size = 2;

        }

        else if (s.find("fcom") != std::string::npos) {

            (*encoding)[0] = 0xD8;

            *encoding_size = 2;

        }

        else if (s.find("paddd") != std::string::npos) {

            (*encoding)[0] = 0x66;

            (*encoding)[1] = 0x0F;

            (*encoding)[2] = 0xFE;

            *encoding_size = 3;

        }

        else if (s.find("psubd") != std::string::npos) {

            (*encoding)[0] = 0x66;

            (*encoding)[1] = 0x0F;

            (*encoding)[2] = 0xFA;

            *encoding_size = 3;

        }

        else if (s.find("pmulld") != std::string::npos) {

            (*encoding)[0] = 0x66;

            (*encoding)[1] = 0x0F;

            (*encoding)[2] = 0x38;

            (*encoding)[3] = 0x40;

            *encoding_size = 4;

        }

        else if (s.find("divpd") != std::string::npos) {

            (*encoding)[0] = 0x66;

            (*encoding)[1] = 0x0F;

            (*encoding)[2] = 0x5E;

            *encoding_size = 3;

        }

        else if (s.find("movdqa") != std::string::npos) {

            (*encoding)[0] = 0x66;

            (*encoding)[1] = 0x0F;

            (*encoding)[2] = 0x6F;

            *encoding_size = 3;

        }

        else if (s.find("pcmpeqd") != std::string::npos) {

            (*encoding)[0] = 0x66;

            (*encoding)[1] = 0x0F;

            (*encoding)[2] = 0x76;

            *encoding_size = 3;

        }

        else if (s.find("pand") != std::string::npos) {

            (*encoding)[0] = 0x66;

            (*encoding)[1] = 0x0F;

            (*encoding)[2] = 0xDB;

            *encoding_size = 3;

        }

        else if (s.find("por") != std::string::npos) {

            (*encoding)[0] = 0x66;

            (*encoding)[1] = 0x0F;

            (*encoding)[2] = 0xEB;

            *encoding_size = 3;

        }

        else if (s.find("pxor") != std::string::npos) {

            (*encoding)[0] = 0x66;

            (*encoding)[1] = 0x0F;

            (*encoding)[2] = 0xEF;

            *encoding_size = 3;

        }

        else if (s.find("pslld") != std::string::npos) {

            (*encoding)[0] = 0x66;

            (*encoding)[1] = 0x0F;

            (*encoding)[2] = 0xF2;

            *encoding_size = 3;

        }

        else if (s.find("psrld") != std::string::npos) {

            (*encoding)[0] = 0x66;

            (*encoding)[1] = 0x0F;

            (*encoding)[2] = 0xD2;

            *encoding_size = 3;

        }

        else if (s.find("psllq") != std::string::npos) {

            (*encoding)[0] = 0x66;

            (*encoding)[1] = 0x0F;

            (*encoding)[2] = 0xF3;

            *encoding_size = 3;

        }

        else if (s.find("psrlq") != std::string::npos) {

            (*encoding)[0] = 0x66;

            (*encoding)[1] = 0x0F;

            (*encoding)[2] = 0xD3;

            *encoding_size = 3;

        }

        else if (s.find("movdqu") != std::string::npos) {

            (*encoding)[0] = 0xF3;

            (*encoding)[1] = 0x0F;

            (*encoding)[2] = 0x6F;

            *encoding_size = 3;

        }

        else if (s.find("cvtsi2sd") != std::string::npos) {

            (*encoding)[0] = 0xF2;

            (*encoding)[1] = 0x0F;

            (*encoding)[2] = 0x2A;

            *encoding_size = 3;

        }

        else if (s.find("cvtsd2si") != std::string::npos) {

            (*encoding)[0] = 0xF2;

            (*encoding)[1] = 0x0F;

            (*encoding)[2] = 0x2D;

            *encoding_size = 3;

        }

        else if (s.find("sqrtsd") != std::string::npos) {

            (*encoding)[0] = 0xF2;

            (*encoding)[1] = 0x0F;

            (*encoding)[2] = 0x51;

            *encoding_size = 3;

        }

        else if (s.find("minsd") != std::string::npos) {

            (*encoding)[0] = 0xF2;

            (*encoding)[1] = 0x0F;

            (*encoding)[2] = 0x5D;

            *encoding_size = 3;

        }

        else if (s.find("maxsd") != std::string::npos) {

            (*encoding)[0] = 0xF2;

            (*encoding)[1] = 0x0F;

            (*encoding)[2] = 0x5F;

            *encoding_size = 3;

        }

        else if (s.find("andpd") != std::string::npos) {

            (*encoding)[0] = 0x66;

            (*encoding)[1] = 0x0F;

            (*encoding)[2] = 0x54;

            *encoding_size = 3;

        }

        else if (s.find("orpd") != std::string::npos) {

            (*encoding)[0] = 0x66;

            (*encoding)[1] = 0x0F;

            (*encoding)[2] = 0x56;

            *encoding_size = 3;

        }

        else if (s.find("xorpd") != std::string::npos) {

            (*encoding)[0] = 0x66;

            (*encoding)[1] = 0x0F;

            (*encoding)[2] = 0x57;

            *encoding_size = 3;

        }

        else if (s.find("blendpd") != std::string::npos) {

            (*encoding)[0] = 0x66;

            (*encoding)[1] = 0x0F;

            (*encoding)[2] = 0x3A;

            (*encoding)[3] = 0x0D;

            *encoding_size = 4;

        }

        }

 else if (s.find("roundpd") != std::string::npos) {

     (*encoding)[0] = 0x66;

     (*encoding)[1] = 0x0F;

     (*encoding)[2] = 0x3A;

     (*encoding)[3] = 0x09;

     *encoding_size = 4;

    }

 else if (s.find("roundps") != std::string::npos) {

     (*encoding)[0] = 0x66;

     (*encoding)[1] = 0x0F;

     (*encoding)[2] = 0x3A;

     (*encoding)[3] = 0x08;

     *encoding_size = 4;

    }

 else if (s.find("blendpd") != std::string::npos) {

     (*encoding)[0] = 0x66;

     (*encoding)[1] = 0x0F;

     (*encoding)[2] = 0x3A;

     (*encoding)[3] = 0x0D;

     *encoding_size = 4;

    }

 else if (s.find("blendps") != std::string::npos) {

     (*encoding)[0] = 0x66;

     (*encoding)[1] = 0x0F;

     (*encoding)[2] = 0x3A;

     (*encoding)[3] = 0x0C;

     *encoding_size = 4;

    }

 else if (s.find("pblendw") != std::string::npos) {

     (*encoding)[0] = 0x66;

     (*encoding)[1] = 0x0F;

     (*encoding)[2] = 0x3A;

     (*encoding)[3] = 0x0E;

     *encoding_size = 4;

    }

 else if (s.find("palignr") != std::string::npos) {

     (*encoding)[0] = 0x66;

     (*encoding)[1] = 0x0F;

     (*encoding)[2] = 0x3A;

     (*encoding)[3] = 0x0F;

     *encoding_size = 4;

    }

 else if (s.find("pextrb") != std::string::npos) {

     (*encoding)[0] = 0x66;

     (*encoding)[1] = 0x0F;

     (*encoding)[2] = 0x3A;

     (*encoding)[3] = 0x14;

     *encoding_size = 4;

    }

 else if (s.find("pextrd") != std::string::npos) {

     (*encoding)[0] = 0x66;

     (*encoding)[1] = 0x0F;

     (*encoding)[2] = 0x3A;

     (*encoding)[3] = 0x16;

     *encoding_size = 4;

    }

 else if (s.find("pextrq") != std::string::npos) {

     (*encoding)[0] = 0x66;

     (*encoding)[1] = 0x0F;

     (*encoding)[2] = 0x3A;

     (*encoding)[3] = 0x16;

     *encoding_size = 4;

    }

 else if (s.find("extractps") != std::string::npos) {

     (*encoding)[0] = 0x66;

     (*encoding)[1] = 0x0F;

     (*encoding)[2] = 0x3A;

     (*encoding)[3] = 0x17;

     *encoding_size = 4;

    }

 else if (s.find("pinsrb") != std::string::npos) {

     (*encoding)[0] = 0x66;

     (*encoding)[1] = 0x0F;

     (*encoding)[2] = 0x3A;

     (*encoding)[3] = 0x20;

     *encoding_size = 4;

    }

 else if (s.find("insertps") != std::string::npos) {

     (*encoding)[0] = 0x66;

     (*encoding)[1] = 0x0F;

     (*encoding)[2] = 0x3A;

     (*encoding)[3] = 0x21;

     *encoding_size = 4;

    }

 else if (s.find("pinsrd") != std::string::npos) {

     (*encoding)[0] = 0x66;

     (*encoding)[1] = 0x0F;

     (*encoding)[2] = 0x3A;

     (*encoding)[3] = 0x22;

     *encoding_size = 4;

    }

 else if (s.find("pinsrq") != std::string::npos) {

     (*encoding)[0] = 0x66;

     (*encoding)[1] = 0x0F;

     (*encoding)[2] = 0x3A;

     (*encoding)[3] = 0x22;

     *encoding_size = 4;

    }

 else if (s.find("dpps") != std::string::npos) {

        (*encoding)[0] = 0x66;

        (*encoding)[1] = 0x0F;

        (*encoding)[2] = 0x3A;

        (*encoding)[3] = 0x40;

        *encoding_size = 4;

        }

 else if (s.find("dppd") != std::string::npos) {

            (*encoding)[0] = 0x66;

            (*encoding)[1] = 0x0F;

            (*encoding)[2] = 0x3A;

            (*encoding)[3] = 0x41;

            *encoding_size = 4;

            }

 else if (s.find("mpsadbw") != std::string::npos) {

                (*encoding)[0] = 0x66;

                (*encoding)[1] = 0x0F;

                (*encoding)[2] = 0x3A;

                (*encoding)[3] = 0x42;

                *encoding_size = 4;

                }

 else if (s.find("pclmulqdq") != std::string::npos) {

                    (*encoding)[0] = 0x66;

                    (*encoding)[1] = 0x0F;

                    (*encoding)[2] = 0x3A;

                    (*encoding)[3] = 0x44;

                    *encoding_size = 4;

                    }

 else if (s.find("blendvps") != std::string::npos) {

                        (*encoding)[0] = 0x66;

                        (*encoding)[1] = 0x0F;

                        (*encoding)[2] = 0x3A;

                        (*encoding)[3] = 0x4A;

                        *encoding_size = 4;

                        }

 else if (s.find("blendvpd") != std::string::npos) {

                            (*encoding)[0] = 0x66;

                            (*encoding)[1] = 0x0F;

                            (*encoding)[2] = 0x3A;

                            (*encoding)[3] = 0x4B;

                            *encoding_size = 4;

                            }

 else if (s.find("pblendvb") != std::string::npos) {

                                (*encoding)[0] = 0x66;

                                (*encoding)[1] = 0x0F;

                                (*encoding)[2] = 0x3A;

                                (*encoding)[3] = 0x4C;

                                *encoding_size = 4;

                                }

 else if (s.find("pcmpestrm") != std::string::npos) {

                                    (*encoding)[0] = 0x66;

                                    (*encoding)[1] = 0x0F;

                                    (*encoding)[2] = 0x3A;

                                    (*encoding)[3] = 0x60;

                                    *encoding_size = 4;

                                    }

 else if (s.find("pcmpestri") != std::string::npos) {

                                        (*encoding)[0] = 0x66;

                                        (*encoding)[1] = 0x0F;

                                        (*encoding)[2] = 0x3A;

                                        (*encoding)[3] = 0x61;

                                        *encoding_size = 4;

                                        }

 else if (s.find("pcmpistrm") != std::string::npos) {

                                            (*encoding)[0] = 0x66;

                                            (*encoding)[1] = 0x0F;

                                            (*encoding)[2] = 0x3A;

                                            (*encoding)[3] = 0x62;

                                            *encoding_size = 4;

                                            }

 else if (s.find("pcmpistri") != std::string::npos) {

                                                (*encoding)[0] = 0x66;

                                                (*encoding)[1] = 0x0F;

                                                (*encoding)[2] = 0x3A;

                                                (*encoding)[3] = 0x63;

                                                *encoding_size = 4;

                                                }

 else if (s.find("aeskeygenassist") != std::string::npos) {

                                                    (*encoding)[0] = 0x66;

                                                    (*encoding)[1] = 0x0F;

                                                    (*encoding)[2] = 0x3A;

                                                    (*encoding)[3] = 0xDF;

                                                    *encoding_size = 4;

                                                    }

 else {

                                                        return KS_ERR_ASM;

                                                        }

                                                        return KS_ERR_OK;

}

void ks_free(unsigned char* encoding) {

    free(encoding);

}

// Bind all handlers to g_handlers array

void bind_handlers() {

    g_handlers[static_cast<uint16_t>(Opcodes::NOP)] = handle_nop;

    g_handlers[static_cast<uint16_t>(Opcodes::ADD)] = handle_add;

    g_handlers[static_cast<uint16_t>(Opcodes::SUB)] = handle_sub;

    g_handlers[static_cast<uint16_t>(Opcodes::MUL)] = handle_mul;

    g_handlers[static_cast<uint16_t>(Opcodes::DIV)] = handle_div;

    g_handlers[static_cast<uint16_t>(Opcodes::AND)] = handle_and;

    g_handlers[static_cast<uint16_t>(Opcodes::OR)] = handle_or;

    g_handlers[static_cast<uint16_t>(Opcodes::NOT)] = handle_not;

    g_handlers[static_cast<uint16_t>(Opcodes::SHL)] = handle_shl;

    g_handlers[static_cast<uint16_t>(Opcodes::SHR)] = handle_shr;

    g_handlers[static_cast<uint16_t>(Opcodes::XOR)] = handle_xor;

    g_handlers[static_cast<uint16_t>(Opcodes::LOAD)] = handle_load;

    g_handlers[static_cast<uint16_t>(Opcodes::STORE)] = handle_store;

    g_handlers[static_cast<uint16_t>(Opcodes::JMP)] = handle_jmp;

    g_handlers[static_cast<uint16_t>(Opcodes::JZ)] = handle_jz;

    g_handlers[static_cast<uint16_t>(Opcodes::JNZ)] = handle_jnz;

    g_handlers[static_cast<uint16_t>(Opcodes::JC)] = handle_jc;

    g_handlers[static_cast<uint16_t>(Opcodes::JNC)] = handle_jnc;

    g_handlers[static_cast<uint16_t>(Opcodes::CMP)] = handle_cmp;

    g_handlers[static_cast<uint16_t>(Opcodes::INC)] = handle_inc;

    g_handlers[static_cast<uint16_t>(Opcodes::DEC)] = handle_dec;

    g_handlers[static_cast<uint16_t>(Opcodes::MOV)] = handle_mov;

    g_handlers[static_cast<uint16_t>(Opcodes::LOAD_IMM)] = handle_load_imm;

    g_handlers[static_cast<uint16_t>(Opcodes::PUSH)] = handle_push;

    g_handlers[static_cast<uint16_t>(Opcodes::POP)] = handle_pop;

    g_handlers[static_cast<uint16_t>(Opcodes::CALL)] = handle_call;

    g_handlers[static_cast<uint16_t>(Opcodes::RET)] = handle_ret;

    g_handlers[static_cast<uint16_t>(Opcodes::IMUL)] = handle_imul;

    g_handlers[static_cast<uint16_t>(Opcodes::IDIV)] = handle_idiv;

    g_handlers[static_cast<uint16_t>(Opcodes::SAR)] = handle_sar;

    g_handlers[static_cast<uint16_t>(Opcodes::ROL)] = handle_rol;

    g_handlers[static_cast<uint16_t>(Opcodes::ROR)] = handle_ror;

    g_handlers[static_cast<uint16_t>(Opcodes::TEST)] = handle_test;

    g_handlers[static_cast<uint16_t>(Opcodes::CMOVE)] = handle_cmove;

    g_handlers[static_cast<uint16_t>(Opcodes::CMOVNE)] = handle_cmovne;

    g_handlers[static_cast<uint16_t>(Opcodes::LEA)] = handle_lea;

    g_handlers[static_cast<uint16_t>(Opcodes::JBE)] = handle_jbe;

    g_handlers[static_cast<uint16_t>(Opcodes::JA)] = handle_ja;

    g_handlers[static_cast<uint16_t>(Opcodes::JS)] = handle_js;

    g_handlers[static_cast<uint16_t>(Opcodes::JNS)] = handle_jns;

    g_handlers[static_cast<uint16_t>(Opcodes::JO)] = handle_jo;

    g_handlers[static_cast<uint16_t>(Opcodes::JNO)] = handle_jno;

    g_handlers[static_cast<uint16_t>(Opcodes::JP)] = handle_jp;

    g_handlers[static_cast<uint16_t>(Opcodes::JNP)] = handle_jnp;

    g_handlers[static_cast<uint16_t>(Opcodes::ADC)] = handle_adc;

    g_handlers[static_cast<uint16_t>(Opcodes::SBB)] = handle_sbb;

    g_handlers[static_cast<uint16_t>(Opcodes::JLE)] = handle_jle;

    g_handlers[static_cast<uint16_t>(Opcodes::JG)] = handle_jg;

    g_handlers[static_cast<uint16_t>(Opcodes::NEG)] = handle_neg;

    g_handlers[static_cast<uint16_t>(Opcodes::BSWAP)] = handle_bswap;

    g_handlers[static_cast<uint16_t>(Opcodes::POPCNT)] = handle_popcnt;

    g_handlers[static_cast<uint16_t>(Opcodes::LZCNT)] = handle_lzcnt;

    g_handlers[static_cast<uint16_t>(Opcodes::TZCNT)] = handle_tzcnt;

    g_handlers[static_cast<uint16_t>(Opcodes::RCL)] = handle_rcl;

    g_handlers[static_cast<uint16_t>(Opcodes::RCR)] = handle_rcr;

    g_handlers[static_cast<uint16_t>(Opcodes::SHLD)] = handle_shld;

    g_handlers[static_cast<uint16_t>(Opcodes::SHRD)] = handle_shrd;

    g_handlers[static_cast<uint16_t>(Opcodes::BT)] = handle_bt;

    g_handlers[static_cast<uint16_t>(Opcodes::BTS)] = handle_bts;

    g_handlers[static_cast<uint16_t>(Opcodes::BTR)] = handle_btr;

    g_handlers[static_cast<uint16_t>(Opcodes::BTC)] = handle_btc;

    g_handlers[static_cast<uint16_t>(Opcodes::CMOVZ)] = handle_cmovz;

    g_handlers[static_cast<uint16_t>(Opcodes::CMOVNZ)] = handle_cmovnz;

    g_handlers[static_cast<uint16_t>(Opcodes::SETZ)] = handle_setz;

    g_handlers[static_cast<uint16_t>(Opcodes::SETNZ)] = handle_setnz;

    g_handlers[static_cast<uint16_t>(Opcodes::SETC)] = handle_setc;

    g_handlers[static_cast<uint16_t>(Opcodes::SETNC)] = handle_setnc;

    g_handlers[static_cast<uint16_t>(Opcodes::SETS)] = handle_sets;

    g_handlers[static_cast<uint16_t>(Opcodes::SETNS)] = handle_setns;

    g_handlers[static_cast<uint16_t>(Opcodes::SETO)] = handle_seto;

    g_handlers[static_cast<uint16_t>(Opcodes::SETNO)] = handle_setno;

    g_handlers[static_cast<uint16_t>(Opcodes::SETP)] = handle_setp;

    g_handlers[static_cast<uint16_t>(Opcodes::SETNP)] = handle_setnp;

    g_handlers[static_cast<uint16_t>(Opcodes::SETBE)] = handle_setbe;

    g_handlers[static_cast<uint16_t>(Opcodes::SETA)] = handle_seta;

    g_handlers[static_cast<uint16_t>(Opcodes::SETLE)] = handle_setle;

    g_handlers[static_cast<uint16_t>(Opcodes::SETG)] = handle_setg;

    g_handlers[static_cast<uint16_t>(Opcodes::CMOVBE)] = handle_cmovbe;

    g_handlers[static_cast<uint16_t>(Opcodes::CMOVA)] = handle_cmova;

    g_handlers[static_cast<uint16_t>(Opcodes::CMOVS)] = handle_cmovs;

    g_handlers[static_cast<uint16_t>(Opcodes::CMOVNS)] = handle_cmovns;

    g_handlers[static_cast<uint16_t>(Opcodes::CMOVO)] = handle_cmovo;

    g_handlers[static_cast<uint16_t>(Opcodes::CMOVNO)] = handle_cmovno;

    g_handlers[static_cast<uint16_t>(Opcodes::CMOVP)] = handle_cmovp;

    g_handlers[static_cast<uint16_t>(Opcodes::CMOVNP)] = handle_cmovnp;

    g_handlers[static_cast<uint16_t>(Opcodes::CMOVLE)] = handle_cmovle;

    g_handlers[static_cast<uint16_t>(Opcodes::CMOVG)] = handle_cmovg;

    g_handlers[static_cast<uint16_t>(Opcodes::BSF)] = handle_bsf;

    g_handlers[static_cast<uint16_t>(Opcodes::BSR)] = handle_bsr;

    g_handlers[static_cast<uint16_t>(Opcodes::MOD)] = handle_mod;

    g_handlers[static_cast<uint16_t>(Opcodes::IMOD)] = handle_imod;

    g_handlers[static_cast<uint16_t>(Opcodes::ADD32)] = handle_add32;

    g_handlers[static_cast<uint16_t>(Opcodes::SUB32)] = handle_sub32;

    g_handlers[static_cast<uint16_t>(Opcodes::MUL32)] = handle_mul32;

    g_handlers[static_cast<uint16_t>(Opcodes::DIV32)] = handle_div32;

    g_handlers[static_cast<uint16_t>(Opcodes::IMUL32)] = handle_imul32;

    g_handlers[static_cast<uint16_t>(Opcodes::IDIV32)] = handle_idiv32;

    g_handlers[static_cast<uint16_t>(Opcodes::MOD32)] = handle_mod32;

    g_handlers[static_cast<uint16_t>(Opcodes::IMOD32)] = handle_imod32;

    g_handlers[static_cast<uint16_t>(Opcodes::FADD)] = handle_fadd;

    g_handlers[static_cast<uint16_t>(Opcodes::FSUB)] = handle_fsub;

    g_handlers[static_cast<uint16_t>(Opcodes::FMUL)] = handle_fmul;

    g_handlers[static_cast<uint16_t>(Opcodes::FDIV)] = handle_fdiv;

    g_handlers[static_cast<uint16_t>(Opcodes::FLD)] = handle_fld;

    g_handlers[static_cast<uint16_t>(Opcodes::FST)] = handle_fst;

    g_handlers[static_cast<uint16_t>(Opcodes::FCMP)] = handle_fcmp;

    g_handlers[static_cast<uint16_t>(Opcodes::PADDD)] = handle_paddd;

    g_handlers[static_cast<uint16_t>(Opcodes::PSUBD)] = handle_psubd;

    g_handlers[static_cast<uint16_t>(Opcodes::PMULD)] = handle_pmuld;

    g_handlers[static_cast<uint16_t>(Opcodes::PDIVD)] = handle_pdivd;

    g_handlers[static_cast<uint16_t>(Opcodes::MOVDQA)] = handle_movdqa;

    g_handlers[static_cast<uint16_t>(Opcodes::PCMPEQD)] = handle_pcmpeqd;

    g_handlers[static_cast<uint16_t>(Opcodes::PAND)] = handle_pand;

    g_handlers[static_cast<uint16_t>(Opcodes::POR)] = handle_por;

    g_handlers[static_cast<uint16_t>(Opcodes::PXOR)] = handle_pxor;

    g_handlers[static_cast<uint16_t>(Opcodes::PSLLD)] = handle_pslld;

    g_handlers[static_cast<uint16_t>(Opcodes::PSRLD)] = handle_psrld;

    g_handlers[static_cast<uint16_t>(Opcodes::PSLLQ)] = handle_psllq;

    g_handlers[static_cast<uint16_t>(Opcodes::PSRLQ)] = handle_psrlq;

    g_handlers[static_cast<uint16_t>(Opcodes::MOVDQU)] = handle_movdqu;

    g_handlers[static_cast<uint16_t>(Opcodes::CVTSI2SD)] = handle_cvtsi2sd;

    g_handlers[static_cast<uint16_t>(Opcodes::CVTSD2SI)] = handle_cvtsd2si;

    g_handlers[static_cast<uint16_t>(Opcodes::SQRTSD)] = handle_sqrtsd;

    g_handlers[static_cast<uint16_t>(Opcodes::MINSD)] = handle_minsd;

    g_handlers[static_cast<uint16_t>(Opcodes::MAXSD)] = handle_maxsd;

    g_handlers[static_cast<uint16_t>(Opcodes::ANDPD)] = handle_andpd;

    g_handlers[static_cast<uint16_t>(Opcodes::ORPD)] = handle_orpd;

    g_handlers[static_cast<uint16_t>(Opcodes::XORPD)] = handle_xorpd;

    g_handlers[static_cast<uint16_t>(Opcodes::BLENDPD)] = handle_blendpd;

    g_handlers[static_cast<uint16_t>(Opcodes::ROUNDPD)] = handle_roundpd;

    g_handlers[static_cast<uint16_t>(Opcodes::VADDPD)] = handle_vaddpd;

    g_handlers[static_cast<uint16_t>(Opcodes::VSUBPD)] = handle_vsubpd;

    g_handlers[static_cast<uint16_t>(Opcodes::VMULPD)] = handle_vmulpd;

    g_handlers[static_cast<uint16_t>(Opcodes::VDIVPD)] = handle_vdivpd;

    g_handlers[static_cast<uint16_t>(Opcodes::VMOVAPD)] = handle_vmovapd;

    g_handlers[static_cast<uint16_t>(Opcodes::VCMP_PD)] = handle_vcmp_pd;

    g_handlers[static_cast<uint16_t>(Opcodes::VBROADCASTSD)] = handle_vbroadcastsd;

    g_handlers[static_cast<uint16_t>(Opcodes::VPERMILPD)] = handle_vpermilpd;

    g_handlers[static_cast<uint16_t>(Opcodes::VFMSUBADDPD)] = handle_vfmsubaddpd;

    g_handlers[static_cast<uint16_t>(Opcodes::VMASKMOVPD)] = handle_vmaskmovpd;

    g_handlers[static_cast<uint16_t>(Opcodes::VGATHERDPD)] = handle_vgatherdpd;

    g_handlers[static_cast<uint16_t>(Opcodes::VSCATTERDPD)] = handle_vscatterdpd;

    g_handlers[static_cast<uint16_t>(Opcodes::VAESENC)] = handle_vaesenc;

    g_handlers[static_cast<uint16_t>(Opcodes::VAESDEC)] = handle_vaesdec;

    g_handlers[static_cast<uint16_t>(Opcodes::VPCLMULQDQ)] = handle_vpclmulqdq;

    g_handlers[static_cast<uint16_t>(Opcodes::VPCMPEQD)] = handle_vpcmpeqd;

    g_handlers[static_cast<uint16_t>(Opcodes::VPSHUFD)] = handle_vpshufd;

    g_handlers[static_cast<uint16_t>(Opcodes::VINSERTF128)] = handle_vinsertf128;

    g_handlers[static_cast<uint16_t>(Opcodes::VEXTRACTF128)] = handle_vextractf128;

    g_handlers[static_cast<uint16_t>(Opcodes::VPERM2F128)] = handle_vperm2f128;

    g_handlers[static_cast<uint16_t>(Opcodes::VBLENDVPD)] = handle_vblendvpd;

    g_handlers[static_cast<uint16_t>(Opcodes::PUSHF)] = handle_pushf;

    g_handlers[static_cast<uint16_t>(Opcodes::POPF)] = handle_popf;

    g_handlers[static_cast<uint16_t>(Opcodes::CPUID)] = handle_cpuid;

    g_handlers[static_cast<uint16_t>(Opcodes::RDTSC)] = handle_rdtsc;

    g_handlers[static_cast<uint16_t>(Opcodes::XCHG)] = handle_xchg;

    g_handlers[static_cast<uint16_t>(Opcodes::CLD)] = handle_cld;

    g_handlers[static_cast<uint16_t>(Opcodes::STD)] = handle_std;

    g_handlers[static_cast<uint16_t>(Opcodes::CLI)] = handle_cli;

    g_handlers[static_cast<uint16_t>(Opcodes::STI)] = handle_sti;

    g_handlers[static_cast<uint16_t>(Opcodes::HLT)] = handle_hlt;

    g_handlers[static_cast<uint16_t>(Opcodes::INT)] = handle_int;

    g_handlers[static_cast<uint16_t>(Opcodes::IRET)] = handle_iret;

    g_handlers[static_cast<uint16_t>(Opcodes::OP_IN)] = handle_op_in;

    g_handlers[static_cast<uint16_t>(Opcodes::OP_OUT)] = handle_op_out;

    g_handlers[static_cast<uint16_t>(Opcodes::LAHF)] = handle_lahf;

    g_handlers[static_cast<uint16_t>(Opcodes::SAHF)] = handle_sahf;

    g_handlers[static_cast<uint16_t>(Opcodes::CLTS)] = handle_clts;

    g_handlers[static_cast<uint16_t>(Opcodes::LGDT)] = handle_lgdt;

    g_handlers[static_cast<uint16_t>(Opcodes::SGDT)] = handle_sgdt;

    g_handlers[static_cast<uint16_t>(Opcodes::LIDT)] = handle_lidt;

    g_handlers[static_cast<uint16_t>(Opcodes::SIDT)] = handle_sidt;

    g_handlers[static_cast<uint16_t>(Opcodes::LMSW)] = handle_lmsw;

    g_handlers[static_cast<uint16_t>(Opcodes::SMSW)] = handle_smsw;

    g_handlers[static_cast<uint16_t>(Opcodes::RDMSR)] = handle_rdmsr;

    g_handlers[static_cast<uint16_t>(Opcodes::WRMSR)] = handle_wrmsr;

    g_handlers[static_cast<uint16_t>(Opcodes::RDPMC)] = handle_rdpmc;

    g_handlers[static_cast<uint16_t>(Opcodes::RSM)] = handle_rsm;

    g_handlers[static_cast<uint16_t>(Opcodes::UD2)] = handle_ud2;

    g_handlers[static_cast<uint16_t>(Opcodes::EMMS)] = handle_emms;

    g_handlers[static_cast<uint16_t>(Opcodes::MOVD)] = handle_movd;

    g_handlers[static_cast<uint16_t>(Opcodes::MOVQ)] = handle_movq;

    g_handlers[static_cast<uint16_t>(Opcodes::PACKSSWB)] = handle_packsswb;

    g_handlers[static_cast<uint16_t>(Opcodes::PACKSSDW)] = handle_packssdw;

    g_handlers[static_cast<uint16_t>(Opcodes::PACKUSWB)] = handle_packuswb;

    g_handlers[static_cast<uint16_t>(Opcodes::MMX_PADDQ)] = handle_mmx_paddq;

    g_handlers[static_cast<uint16_t>(Opcodes::MMX_PADDB)] = handle_mmx_paddb;

    g_handlers[static_cast<uint16_t>(Opcodes::MMX_PADDW)] = handle_mmx_paddw;

    g_handlers[static_cast<uint16_t>(Opcodes::MMX_PADDD)] = handle_mmx_paddd;

    g_handlers[static_cast<uint16_t>(Opcodes::MMX_PSUBB)] = handle_mmx_psubb;

    g_handlers[static_cast<uint16_t>(Opcodes::MMX_PSUBW)] = handle_mmx_psubw;

    g_handlers[static_cast<uint16_t>(Opcodes::MMX_PSUBD)] = handle_mmx_psubd;

    g_handlers[static_cast<uint16_t>(Opcodes::MMX_PSUBQ)] = handle_mmx_psubq;

    g_handlers[static_cast<uint16_t>(Opcodes::PMADDWD)] = handle_pmaddwd;

    g_handlers[static_cast<uint16_t>(Opcodes::PMULHW)] = handle_pmulhw;

    g_handlers[static_cast<uint16_t>(Opcodes::PMULLW)] = handle_pmullw;

    g_handlers[static_cast<uint16_t>(Opcodes::PAVGB)] = handle_pavgb;

    g_handlers[static_cast<uint16_t>(Opcodes::PAVGW)] = handle_pavgw;

    g_handlers[static_cast<uint16_t>(Opcodes::PMINUB)] = handle_pminub;

    g_handlers[static_cast<uint16_t>(Opcodes::PMAXUB)] = handle_pmaxub;

    g_handlers[static_cast<uint16_t>(Opcodes::PMINSW)] = handle_pminsw;

    g_handlers[static_cast<uint16_t>(Opcodes::PMAXSW)] = handle_pmaxsw;

    g_handlers[static_cast<uint16_t>(Opcodes::PSADBW)] = handle_psadbw;

    g_handlers[static_cast<uint16_t>(Opcodes::PSHUFW)] = handle_pshufw;

    g_handlers[static_cast<uint16_t>(Opcodes::MASKMOVQ)] = handle_maskmovq;

    g_handlers[static_cast<uint16_t>(Opcodes::MOVNTQ)] = handle_movntq;

    g_handlers[static_cast<uint16_t>(Opcodes::PANDN)] = handle_pandn;

    g_handlers[static_cast<uint16_t>(Opcodes::PCMPGTB)] = handle_pcmpgtb;

    g_handlers[static_cast<uint16_t>(Opcodes::PCMPGTW)] = handle_pcmpgtw;

    g_handlers[static_cast<uint16_t>(Opcodes::PCMPGTD)] = handle_pcmpgtd;

    g_handlers[static_cast<uint16_t>(Opcodes::PEXTRW)] = handle_pextrw;

    g_handlers[static_cast<uint16_t>(Opcodes::PINSRW)] = handle_pinsrw;

    g_handlers[static_cast<uint16_t>(Opcodes::PMADDUBSW)] = handle_pmaddubsw;

    g_handlers[static_cast<uint16_t>(Opcodes::PMAXSD)] = handle_pmaxsd;

    g_handlers[static_cast<uint16_t>(Opcodes::PMINSD)] = handle_pminsd;

    g_handlers[static_cast<uint16_t>(Opcodes::PMULUDQ)] = handle_pmuludq;

    g_handlers[static_cast<uint16_t>(Opcodes::PSHUFB)] = handle_pshufb;

    g_handlers[static_cast<uint16_t>(Opcodes::PSIGNB)] = handle_psignb;

    g_handlers[static_cast<uint16_t>(Opcodes::PSIGNW)] = handle_psignw;

    g_handlers[static_cast<uint16_t>(Opcodes::PSIGND)] = handle_psignd;

    g_handlers[static_cast<uint16_t>(Opcodes::PSUBUSB)] = handle_psubusb;

    g_handlers[static_cast<uint16_t>(Opcodes::PSUBUSW)] = handle_psubusw;

    g_handlers[static_cast<uint16_t>(Opcodes::PSRLW)] = handle_psrlw;

    g_handlers[static_cast<uint16_t>(Opcodes::PSRAW)] = handle_psraw;

    g_handlers[static_cast<uint16_t>(Opcodes::PSLLW)] = handle_psllw;

    g_handlers[static_cast<uint16_t>(Opcodes::PSUBSB)] = handle_psubsb;

    g_handlers[static_cast<uint16_t>(Opcodes::PSUBSW)] = handle_psubsw;

    g_handlers[static_cast<uint16_t>(Opcodes::PUNPCKLBW)] = handle_punpcklbw;

    g_handlers[static_cast<uint16_t>(Opcodes::PUNPCKLWD)] = handle_punpcklwd;

    g_handlers[static_cast<uint16_t>(Opcodes::PUNPCKLDQ)] = handle_punpckldq;

    g_handlers[static_cast<uint16_t>(Opcodes::PUNPCKHBW)] = handle_punpckhbw;

    g_handlers[static_cast<uint16_t>(Opcodes::PUNPCKHWD)] = handle_punpckhwd;

    g_handlers[static_cast<uint16_t>(Opcodes::PUNPCKHDQ)] = handle_punpckhdq;

    g_handlers[static_cast<uint16_t>(Opcodes::MOVD_EXT)] = handle_movd_ext;

    g_handlers[static_cast<uint16_t>(Opcodes::MOVQ_EXT)] = handle_movq_ext;

    g_handlers[static_cast<uint16_t>(Opcodes::PMOVMSKB)] = handle_pmovmskb;

    g_handlers[static_cast<uint16_t>(Opcodes::PMULHRSW)] = handle_pmulhrsw;

    g_handlers[static_cast<uint16_t>(Opcodes::PSHUFLW)] = handle_pshuflw;

    g_handlers[static_cast<uint16_t>(Opcodes::PSHUFHW)] = handle_pshufhw;

    g_handlers[static_cast<uint16_t>(Opcodes::PSLLDQ)] = handle_pslldq;

    g_handlers[static_cast<uint16_t>(Opcodes::PSRLDQ)] = handle_psrldq;

    g_handlers[static_cast<uint16_t>(Opcodes::PTEST)] = handle_ptest;

    g_handlers[static_cast<uint16_t>(Opcodes::VADDPS)] = handle_vaddps;

    g_handlers[static_cast<uint16_t>(Opcodes::VSUBPS)] = handle_vsubps;

    g_handlers[static_cast<uint16_t>(Opcodes::VMULPS)] = handle_vmulps;

    g_handlers[static_cast<uint16_t>(Opcodes::VDIVPS)] = handle_vdivps;

    g_handlers[static_cast<uint16_t>(Opcodes::VANDPS)] = handle_vandps;

    g_handlers[static_cast<uint16_t>(Opcodes::VORPS)] = handle_vorps;

    g_handlers[static_cast<uint16_t>(Opcodes::VXORPS)] = handle_vxorps;

    g_handlers[static_cast<uint16_t>(Opcodes::VBLENDPS)] = handle_vblendps;

    g_handlers[static_cast<uint16_t>(Opcodes::VMINPS)] = handle_vminps;

    g_handlers[static_cast<uint16_t>(Opcodes::VMAXPS)] = handle_vmaxps;

    g_handlers[static_cast<uint16_t>(Opcodes::EXIT)] = handle_exit;

    g_handlers[static_cast<uint16_t>(Opcodes::JUNK1)] = handle_junk;

    g_handlers[static_cast<uint16_t>(Opcodes::JUNK2)] = handle_junk;

    g_handlers[static_cast<uint16_t>(Opcodes::JUNK3)] = handle_junk;

    g_handlers[static_cast<uint16_t>(Opcodes::JUNK4)] = handle_junk;

    g_handlers[static_cast<uint16_t>(Opcodes::JUNK5)] = handle_junk;

    g_handlers[static_cast<uint16_t>(Opcodes::JUNK6)] = handle_junk;

    g_handlers[static_cast<uint16_t>(Opcodes::JUNK7)] = handle_junk;

    g_handlers[static_cast<uint16_t>(Opcodes::JUNK8)] = handle_junk;

    g_handlers[static_cast<uint16_t>(Opcodes::JUNK9)] = handle_junk;

    g_handlers[static_cast<uint16_t>(Opcodes::JUNK10)] = handle_junk;

    g_handlers[static_cast<uint16_t>(Opcodes::JUNK11)] = handle_junk;

    g_handlers[static_cast<uint16_t>(Opcodes::JUNK12)] = handle_junk;

    g_handlers[static_cast<uint16_t>(Opcodes::JUNK13)] = handle_junk;

    g_handlers[static_cast<uint16_t>(Opcodes::JUNK14)] = handle_junk;

    g_handlers[static_cast<uint16_t>(Opcodes::JUNK15)] = handle_junk;

    g_handlers[static_cast<uint16_t>(Opcodes::JUNK16)] = handle_junk;

    g_handlers[static_cast<uint16_t>(Opcodes::JUNK17)] = handle_junk;

    g_handlers[static_cast<uint16_t>(Opcodes::JUNK18)] = handle_junk;

    g_handlers[static_cast<uint16_t>(Opcodes::JUNK19)] = handle_junk;

    g_handlers[static_cast<uint16_t>(Opcodes::JUNK20)] = handle_junk;

}

// Implement all handlers

void handle_nop(VMContext* ctx, uint8_t* instr) {

    // No operation

    LOG_DEBUG("NOP");

}

void handle_add(VMContext* ctx, uint8_t* instr) {

    uint8_t r_dst = read_operand<uint8_t>(ctx);

    uint8_t r_src = read_operand<uint8_t>(ctx);

    if (r_dst >= NUM_REGISTERS || r_src >= NUM_REGISTERS) {

        ctx->last_error = ProtectionError::ERROR_INVALID_REGISTER;

        ctx->running = false;

        return;

    }

    uint64_t val1 = ctx->regs[r_dst];

    uint64_t val2 = ctx->regs[r_src];

    uint64_t result = val1 + val2;

    ctx->flags.carry = (result < val1);

    ctx->flags.overflow = (((val1 ^ result) & (val2 ^ result)) >> 63);

    ctx->regs[r_dst] = result;

    ctx->flags.zero = (result == 0);

    ctx->flags.sign = (result >> 63);

    ctx->flags.parity = parity_even(result);

    LOG_DEBUG("ADD");

}

void handle_sub(VMContext* ctx, uint8_t* instr) {

    uint8_t r_dst = read_operand<uint8_t>(ctx);

    uint8_t r_src = read_operand<uint8_t>(ctx);

    if (r_dst >= NUM_REGISTERS || r_src >= NUM_REGISTERS) {

        ctx->last_error = ProtectionError::ERROR_INVALID_REGISTER;

        ctx->running = false;

        return;

    }

    uint64_t val1 = ctx->regs[r_dst];

    uint64_t val2 = ctx->regs[r_src];

    uint64_t result = val1 - val2;

    ctx->flags.carry = (val1 < val2);

    ctx->flags.overflow = (((val1 ^ val2) & (val1 ^ result)) >> 63);

    ctx->regs[r_dst] = result;

    ctx->flags.zero = (result == 0);

    ctx->flags.sign = (result >> 63);

    ctx->flags.parity = parity_even(result);

    LOG_DEBUG("SUB");

}

void handle_mul(VMContext* ctx, uint8_t* instr) {

    uint8_t r_dst = read_operand<uint8_t>(ctx);

    uint8_t r_src = read_operand<uint8_t>(ctx);

    if (r_dst >= NUM_REGISTERS || r_src >= NUM_REGISTERS) {

        ctx->last_error = ProtectionError::ERROR_INVALID_REGISTER;

        ctx->running = false;

        return;

    }

    uint64_t val1 = ctx->regs[r_dst];

    uint64_t val2 = ctx->regs[r_src];

    __int128 result = (__int128)val1 * val2;

    ctx->regs[r_dst] = static_cast<uint64_t>(result);

    ctx->flags.carry = (result > UINT64_MAX);

    ctx->flags.overflow = ctx->flags.carry;

    ctx->flags.zero = (ctx->regs[r_dst] == 0);

    ctx->flags.sign = (ctx->regs[r_dst] >> 63);

    ctx->flags.parity = parity_even(ctx->regs[r_dst]);

    LOG_DEBUG("MUL");

}

void handle_div(VMContext* ctx, uint8_t* instr) {

    uint8_t r_src = read_operand<uint8_t>(ctx);

    if (r_src >= NUM_REGISTERS) {

        ctx->last_error = ProtectionError::ERROR_INVALID_REGISTER;

        ctx->running = false;

        return;

    }

    uint64_t divisor = ctx->regs[r_src];

    if (divisor == 0) {

        ctx->last_error = ProtectionError::ERROR_DIVISION_BY_ZERO;

        ctx->running = false;

        return;

    }

    uint64_t dividend_low = ctx->regs[0]; // Assume R0 is AX, R3 is DX

    uint64_t dividend_high = ctx->regs[3];

    __int128 dividend = ((__int128)dividend_high << 64) | dividend_low;

    uint64_t quotient = dividend / divisor;

    uint64_t remainder = dividend % divisor;

    ctx->regs[0] = quotient;

    ctx->regs[3] = remainder;

    LOG_DEBUG("DIV");

}

// Implement similar for all other basic ops

// For FPU

void handle_fadd(VMContext* ctx, uint8_t* instr) {

    // Assume ST(0) + ST(i)

    uint8_t st_i = read_operand<uint8_t>(ctx);

    if (ctx->fpu_top <= st_i) {

        ctx->last_error = ProtectionError::ERROR_FPU_STACK_OVERFLOW;

        ctx->running = false;

        return;

    }

    ctx->fpu_stack[0] += ctx->fpu_stack[st_i];

    LOG_DEBUG("FADD");

}

void handle_fsub(VMContext* ctx, uint8_t* instr) {

    uint8_t st_i = read_operand<uint8_t>(ctx);

    if (ctx->fpu_top <= st_i) {

        ctx->last_error = ProtectionError::ERROR_FPU_STACK_OVERFLOW;

        ctx->running = false;

        return;

    }

    ctx->fpu_stack[0] -= ctx->fpu_stack[st_i];

    LOG_DEBUG("FSUB");

}

// Similar for fmul, fdiv, fld, fst, fcmp

// For SSE

void handle_paddd(VMContext* ctx, uint8_t* instr) {

    uint8_t xmm_dst = read_operand<uint8_t>(ctx);

    uint8_t xmm_src = read_operand<uint8_t>(ctx);

    if (xmm_dst >= NUM_REGISTERS || xmm_src >= NUM_REGISTERS) {

        ctx->last_error = ProtectionError::ERROR_INVALID_REGISTER;

        ctx->running = false;

        return;

    }

    __m128i dst = _mm_load_si128((__m128i*) & ctx->xmm_regs[xmm_dst]);

    __m128i src = _mm_load_si128((__m128i*) & ctx->xmm_regs[xmm_src]);

    __m128i result = _mm_add_epi32(dst, src);

    _mm_store_si128((__m128i*) & ctx->xmm_regs[xmm_dst], result);

    LOG_DEBUG("PADDD");

}

// Implement all SSE handlers similarly

// For AVX

void handle_vaddpd(VMContext* ctx, uint8_t* instr) {

    // Stub for now

    LOG_DEBUG("VADDPD");

}

// Implement all

// For junk

void handle_junk(VMContext* ctx, uint8_t* instr) {

    // Pointless ops

    uint64_t temp = ctx->regs[0] + ctx->regs[1] - ctx->regs[1];

    ctx->regs[0] = temp;

    LOG_DEBUG("JUNK");

}

// For exit

void handle_exit(VMContext* ctx, uint8_t* instr) {

    ctx->running = false;

    LOG_DEBUG("EXIT");

}

// VM Initialization and Execution

void InitVM(VMContext& ctx, uint8_t* data, size_t data_size, std::ostream* log) {

    std::memset(&ctx, 0, sizeof(ctx));

    ctx.ip = data;

    ctx.running = true;

    ctx.last_error = ProtectionError::SUCCESS;

    ctx.stack.resize(STACK_SIZE_INITIAL);

    ctx.sp = STACK_SIZE_INITIAL;

    ctx.memory.resize(0x10000);

    ctx.code_hash = compute_code_hash(data, data_size);

    ctx.step_count = 0;

}

void run_vm(VMContext* ctx, uint64_t max_steps) {

    bind_handlers();

    while (ctx->running && ctx->step_count < max_steps) {

        if (ctx->step_count % 100 == 0) {

            if (compute_code_hash(ctx->ip, 4096) != ctx->code_hash) {

                ctx->last_error = ProtectionError::ERROR_TAMPERING_DETECTED;

                ctx->running = false;

                return;

            }

        }

        uint16_t opcode = *reinterpret_cast<uint16_t*>(ctx->ip);

        ctx->ip += sizeof(uint16_t);

        if (opcode >= 0x114) {

            ctx->last_error = ProtectionError::ERROR_INVALID_OPCODE;

            ctx->running = false;

            return;

        }

        g_handlers[opcode](ctx, ctx->ip);

        ctx->step_count++;

    }

    if (ctx->step_count >= max_steps) {

        ctx->last_error = ProtectionError::ERROR_VM_HALT;

        ctx->running = false;

    }

}

// Protection Workflow

void protect_function(const std::string& dll_path, uint64_t func_rva, const ProtectorSettings& settings) {

    // Implementation as in previous

    // Disassemble, lift to IR, recompile to VM bytecode, patch DLL

}

void generate_loader(const std::string& protected_dll, const std::string& protected_meta, const ProtectorSettings& settings) {

    // Generate C++ source for loader, compile to exe

}

// Cryptography

bool encrypt_file(const std::string& input_path, const std::string& output_path) {

    // Implementation

}

// Etc.

void handle_jc(VMContext* ctx, uint8_t* instr) {

    int64_t offset = read_operand<int64_t>(ctx);

    if (ctx->flags.carry) {

        ctx->ip += offset - sizeof(int64_t);

    }

    LOG_DEBUG("JC");

} write this out 3 times longer fully! so that is works with these! // protector_main.cpp

// Main entry point for the protector application.

// Features a Win32 GUI to select files, specify parameters, and initiate the protection process.

// The protection logic is run on a separate thread to keep the UI responsive.

#include <windows.h>

#include <commdlg.h>

#include <string>

#include <iostream>

#include <vector>

#include <process.h> // For _beginthreadex

#include <Richedit.h> // For the log box

#include "loader_core.h"

// --- Control IDs ---

#define IDC_DLL_EDIT 101

#define IDC_DLL_BUTTON 102

#define IDC_META_EDIT 103

#define IDC_META_BUTTON 104

#define IDC_RVA_EDIT 105

#define IDC_PROTECT_BUTTON 106

#define IDC_LOG_RICHEDIT 107

#define IDM_FILE_EXIT 201

#define IDM_HELP_ABOUT 202

// --- Custom Window Messages ---

#define WM_APP_LOG_MSG (WM_APP + 1)

// --- Global Variables ---

HWND hWnd;

HWND hEditDll, hEditMetadata, hEditRva, hBtnProtect, hLog;

HINSTANCE hInst;

HFONT hFont;

// Struct to pass parameters to the worker thread

struct ThreadParams {

    std::string dll_path;

    std::string metadata_path;

    uint64_t function_rva;

};

// --- Function Prototypes ---

LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);

void AddControls(HWND);

void CreateMainMenu(HWND);

void LogMessage(const std::string& msg);

unsigned __stdcall ProtectionThread(void* pArguments);

// --- Main Entry Point ---

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow) {

    hInst = hInstance;

    std::srand(static_cast<unsigned>(std::time(nullptr)));

    // Load the rich edit library

    LoadLibraryA("Richedit20.dll");

    WNDCLASSA wc = { 0 };

    wc.style = CS_HREDRAW | CS_VREDRAW;

    wc.lpfnWndProc = WndProc;

    wc.hInstance = hInstance;

    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);

    wc.lpszClassName = "UnityProtectorClass";

    wc.hCursor = LoadCursor(NULL, IDC_ARROW);

    RegisterClassA(&wc);

    hWnd = CreateWindowA("UnityProtectorClass", "Unity Game Protector - 2025 Edition",

        WS_OVERLAPPEDWINDOW & ~WS_MAXIMIZEBOX, // Disable maximize

        CW_USEDEFAULT, CW_USEDEFAULT, 600, 450,

        NULL, NULL, hInstance, NULL);

    ShowWindow(hWnd, nCmdShow);

    UpdateWindow(hWnd);

    MSG msg;

    while (GetMessageA(&msg, NULL, 0, 0)) {

        TranslateMessage(&msg);

        DispatchMessageA(&msg);

    }

    return (int)msg.wParam;

}

// --- Window Procedure ---

LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam) {

    switch (message) {

    case WM_CREATE:

        CreateMainMenu(hWnd);

        AddControls(hWnd);

        break;

    case WM_COMMAND: {

        switch (LOWORD(wParam)) {

        case IDM_FILE_EXIT:

            PostQuitMessage(0);

            break;

        case IDM_HELP_ABOUT:

            MessageBoxA(hWnd, "Unity Game Protector\nVersion 1.0\n\nAn IL2CPP Obfuscator for Unity.", "About", MB_OK | MB_ICONINFORMATION);

            break;

        case IDC_DLL_BUTTON: {

            char szFile[MAX_PATH] = { 0 };

            OPENFILENAMEA ofn = { sizeof(ofn) };

            ofn.hwndOwner = hWnd;

            ofn.lpstrFile = szFile;

            ofn.nMaxFile = sizeof(szFile);

            ofn.lpstrFilter = "GameAssembly DLL\0GameAssembly.dll\0All DLLs\0*.dll\0";

            ofn.Flags = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST;

            if (GetOpenFileNameA(&ofn)) {

                SetWindowTextA(hEditDll, szFile);

            }

        }

                           break;

        case IDC_META_BUTTON: {

            char szFile[MAX_PATH] = { 0 };

            OPENFILENAMEA ofn = { sizeof(ofn) };

            ofn.hwndOwner = hWnd;

            ofn.lpstrFile = szFile;

            ofn.nMaxFile = sizeof(szFile);

            ofn.lpstrFilter = "Metadata File\0global-metadata.dat\0All Files\0*.*\0";

            ofn.Flags = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST;

            if (GetOpenFileNameA(&ofn)) {

                SetWindowTextA(hEditMetadata, szFile);

            }

        }

                            break;

        case IDC_PROTECT_BUTTON: {

            char dll_buf[MAX_PATH], meta_buf[MAX_PATH], rva_buf[32];

            GetWindowTextA(hEditDll, dll_buf, MAX_PATH);

            GetWindowTextA(hEditMetadata, meta_buf, MAX_PATH);

            GetWindowTextA(hEditRva, rva_buf, 32);

            if (strlen(dll_buf) == 0 || strlen(meta_buf) == 0 || strlen(rva_buf) == 0) {

                MessageBoxA(hWnd, "Please fill in all fields before protecting.", "Input Error", MB_OK | MB_ICONWARNING);

                return 0;

            }

            uint64_t func_rva = 0;

            try {

                func_rva = std::stoull(rva_buf, nullptr, 16);

            }

            catch (...) {

                MessageBoxA(hWnd, "Invalid RVA format. Please enter a hexadecimal value (e.g., 0x123AB).", "Input Error", MB_OK | MB_ICONERROR);

                return 0;

            }

            // Use a struct to pass data to the new thread

            ThreadParams* params = new ThreadParams;

            params->dll_path = dll_buf;

            params->metadata_path = meta_buf;

            params->function_rva = func_rva;

            // Disable UI and start worker thread

            EnableWindow(hBtnProtect, FALSE);

            SetWindowTextA(hLog, ""); // Clear log

            LogMessage("Starting protection process...\n");

            _beginthreadex(NULL, 0, ProtectionThread, params, 0, NULL);

        }

                               break;

        }

    }

                   break;

                   // Custom message from worker thread to log text

    case WM_APP_LOG_MSG: {

        char* msg = (char*)lParam;

        LogMessage(msg);

        delete[] msg; // Free the allocated memory

    }

                       break;

    case WM_DESTROY:

        DeleteObject(hFont);

        PostQuitMessage(0);

        break;

    default:

        return DefWindowProcA(hWnd, message, wParam, lParam);

    }

    return 0;

}

// --- UI Creation ---

void AddControls(HWND hWnd) {

    hFont = CreateFontA(16, 0, 0, 0, FW_NORMAL, FALSE, FALSE, FALSE, DEFAULT_CHARSET,

        OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY,

        DEFAULT_PITCH | FF_SWISS, "Segoe UI");

    auto CreateLabel = [&](const char* text, int x, int y, int w, int h) {

        HWND hStatic = CreateWindowA("STATIC", text, WS_CHILD | WS_VISIBLE, x, y, w, h, hWnd, NULL, hInst, NULL);

        SendMessage(hStatic, WM_SETFONT, (WPARAM)hFont, TRUE);

        };

    // DLL Path

    CreateLabel("Target DLL:", 10, 10, 150, 20);

    hEditDll = CreateWindowA("EDIT", "", WS_CHILD | WS_VISIBLE | WS_BORDER, 10, 35, 450, 25, hWnd, (HMENU)IDC_DLL_EDIT, hInst, NULL);

    CreateWindowA("BUTTON", "...", WS_CHILD | WS_VISIBLE, 470, 35, 100, 25, hWnd, (HMENU)IDC_DLL_BUTTON, hInst, NULL);

    // Metadata Path

    CreateLabel("Metadata File:", 10, 70, 150, 20);

    hEditMetadata = CreateWindowA("EDIT", "", WS_CHILD | WS_VISIBLE | WS_BORDER, 10, 95, 450, 25, hWnd, (HMENU)IDC_META_EDIT, hInst, NULL);

    CreateWindowA("BUTTON", "...", WS_CHILD | WS_VISIBLE, 470, 95, 100, 25, hWnd, (HMENU)IDC_META_BUTTON, hInst, NULL);

    // Function RVA

    CreateLabel("Function RVA (hex):", 10, 130, 150, 20);

    // **FIX:** Corrected the typo from HMENUSIGNED to HMENU.

    hEditRva = CreateWindowA("EDIT", "0x", WS_CHILD | WS_VISIBLE | WS_BORDER, 10, 155, 450, 25, hWnd, (HMENU)IDC_RVA_EDIT, hInst, NULL);

    // Protect Button

    hBtnProtect = CreateWindowA("BUTTON", "Protect Files", WS_CHILD | WS_VISIBLE | BS_DEFPUSHBUTTON, 470, 155, 100, 25, hWnd, (HMENU)IDC_PROTECT_BUTTON, hInst, NULL);

    // Log Window

    CreateLabel("Log:", 10, 190, 100, 20);

    hLog = CreateWindowExA(0, RICHEDIT_CLASSA, "",

        WS_CHILD | WS_VISIBLE | WS_VSCROLL | WS_BORDER | ES_MULTILINE | ES_AUTOVSCROLL | ES_READONLY,

        10, 215, 560, 150, hWnd, (HMENU)IDC_LOG_RICHEDIT, hInst, NULL);

    // Set font for all controls

    SendMessage(hEditDll, WM_SETFONT, (WPARAM)hFont, TRUE);

    SendMessage(hEditMetadata, WM_SETFONT, (WPARAM)hFont, TRUE);

    SendMessage(hEditRva, WM_SETFONT, (WPARAM)hFont, TRUE);

    SendMessage(hBtnProtect, WM_SETFONT, (WPARAM)hFont, TRUE);

    SendMessage(hLog, WM_SETFONT, (WPARAM)hFont, TRUE);

}

void CreateMainMenu(HWND hWnd) {

    HMENU hMenubar = CreateMenu();

    HMENU hFileMenu = CreateMenu();

    HMENU hHelpMenu = CreateMenu();

    AppendMenuA(hFileMenu, MF_STRING, IDM_FILE_EXIT, "Exit");

    AppendMenuA(hHelpMenu, MF_STRING, IDM_HELP_ABOUT, "About");

    AppendMenuA(hMenubar, MF_POPUP, (UINT_PTR)hFileMenu, "File");

    AppendMenuA(hMenubar, MF_POPUP, (UINT_PTR)hHelpMenu, "Help");

    SetMenu(hWnd, hMenubar);

}

// --- Logging and Threading ---

// Safely appends a message to the rich edit control from any thread

void LogMessage(const std::string& msg) {

    // If called from a worker thread, post a message. Otherwise, update directly.

    if (GetCurrentThreadId() != GetWindowThreadProcessId(hWnd, NULL)) {

        size_t len = msg.length() + 1;

        char* buf = new char[len];

        strcpy_s(buf, len, msg.c_str());

        PostMessage(hWnd, WM_APP_LOG_MSG, 0, (LPARAM)buf);

    }

    else {

        // Correct way to append text

        CHARRANGE cr;

        cr.cpMin = -1;

        cr.cpMax = -1;

        SendMessage(hLog, EM_EXSETSEL, 0, (LPARAM)&cr);

        SendMessage(hLog, EM_REPLACESEL, 0, (LPARAM)msg.c_str());

    }

}

// Worker thread to handle the protection process

unsigned __stdcall ProtectionThread(void* pArguments) {

    ThreadParams* params = static_cast<ThreadParams*>(pArguments);

    ProtectorSettings settings;

    // settings.enable_anti_debugging = false; // Example of changing a setting

    try {

        std::string protected_dll = params->dll_path + ".protected";

        std::string protected_meta = params->metadata_path + ".protected";

        LogMessage("Step 1/4: Encrypting DLL...\n");

        if (!encrypt_file(params->dll_path, protected_dll)) {

            throw std::runtime_error("Failed to encrypt DLL file.");

        }

        LogMessage("Step 2/4: Encrypting Metadata...\n");

        if (!encrypt_file(params->metadata_path, protected_meta)) {

            throw std::runtime_error("Failed to encrypt metadata file.");

        }

        LogMessage("Step 3/4: Virtualizing function at RVA " + to_hex_string(params->function_rva) + "...\n");

        protect_function(params->dll_path, params->function_rva, settings);

        LogMessage("Step 4/4: Generating loader executable...\n");

        generate_loader(protected_dll, protected_meta, settings);

        LogMessage("\nProtection successful! ✅\n");

        LogMessage("Protected DLL: " + protected_dll + "\n");

        LogMessage("Protected Metadata: " + protected_meta + "\n");

    }

    catch (const std::exception& e) {

        LogMessage("\nERROR: " + std::string(e.what()) + "\n");

    }

    catch (...) {

        LogMessage("\nAn unknown critical error occurred. ❌\n");

    }

    // Re-enable the button and clean up

    EnableWindow(hBtnProtect, TRUE);

    delete params;

    return 0;

} // loader_core.h

//

// This is the central header file for the entire virtualization and protection engine.

// It defines all core data structures, constants, error codes, VM opcodes,

// and function prototypes used by the protector and the generated loader.

//

#ifndef LOADER_CORE_H

#define LOADER_CORE_H

// --- System and Standard Library Includes ---

#include <windows.h>

#include <commdlg.h>

#include <fstream>

#include <vector>

#include <string>

#include <cstdint>

#include <map>

#include <iostream>

#include <random>

#include <ctime>

#include <wincrypt.h>

#include <cstring>

#include <cstddef>

#include <bcrypt.h>

#include <array>

#include <psapi.h>

#include <imagehlp.h>

#include <sstream>

#include <winternl.h>

#include <xmmintrin.h>

#include <immintrin.h>

#include <algorithm>

#include <cmath>

#include <limits>

#include <memory>

#include <stdexcept>

#include <iomanip>

#include <intrin.h>

// --- Preprocessor Definitions and Undefinitions ---

#ifdef max

#undef max

#endif

#ifdef min

#undef min

#endif

#ifdef ERROR_STACK_OVERFLOW

#undef ERROR_STACK_OVERFLOW

#endif

// --- Type Definitions for Windows Internals ---

#ifndef NTSTATUS

typedef LONG NTSTATUS;

#endif

#ifndef STATUS_SUCCESS

#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)

#endif

// For NtQuerySystemInformation anti-debugging check

typedef enum _SYSTEM_INFORMATION_CLASS {

    SystemKernelDebuggerInformation = 0x23

} SYSTEM_INFORMATION_CLASS;

typedef struct _SYSTEM_KERNEL_DEBUGGER_INFORMATION {

    BOOLEAN KernelDebuggerEnabled;

    BOOLEAN KernelDebuggerNotPresent;

} SYSTEM_KERNEL_DEBUGGER_INFORMATION, * PSYSTEM_KERNEL_DEBUGGER_INFORMATION;

// --- Debug Logging Macro ---

#ifdef _DEBUG

#define LOG_DEBUG(msg) OutputDebugStringA((std::string("[DEBUG] ") + msg + "\n").c_str())

#else

#define LOG_DEBUG(msg)

#endif

// --- Core Constants ---

const int NUM_REGISTERS = 16;

const int MAX_BYTECODE_SIZE = 16384;

const int STACK_SIZE_INITIAL = 4096;

const int VM_EXECUTION_TIMEOUT = 10000000;

const char* LOADER_SECTION_NAME = ".vmp";

// Obfuscation parameters

const int JUNK_INSERTION_PROBABILITY = 15;

const int MAX_JUNK_PER_INSTRUCTION = 3;

const int MAX_JUNK_INSERTIONS = 1000;

const int RANDOM_SEED_MODIFIER = 42;

// Alignment and precision constants

const int MEMORY_ALIGNMENT_REQUIREMENT = 16;

const int FPU_PRECISION_BITS = 53;

const int SSE_ALIGNMENT = 16;

const int AVX_ALIGNMENT = 32;

// Cryptography constants

const int AES_KEY_SIZE_BYTES = 32;

const int GCM_NONCE_SIZE_BYTES = 12;

const int GCM_TAG_SIZE_BYTES = 16;

const int AES_KEY_SIZE = 32; // Alias for legacy constants

const int NONCE_SIZE = 12; // Alias for legacy constants

const int TAG_SIZE = 16; // Alias for legacy constants

// --- Comprehensive Error Codes ---

enum class ProtectionError : int {

    SUCCESS = 0,

    // VM Execution Errors

    ERROR_INVALID_OPCODE = -1,

    ERROR_OUT_OF_BOUNDS = -2,

    ERROR_STACK_OVERFLOW = -3,

    ERROR_STACK_UNDERFLOW = -4,

    ERROR_DIVISION_BY_ZERO = -5,

    ERROR_MOD_BY_ZERO = -6,

    ERROR_INVALID_REGISTER = -7,

    ERROR_VM_HALT = -8,

    ERROR_INVALID_MEMORY = -9,

    ERROR_FLOAT_OVERFLOW = -10,

    ERROR_INVALID_INSTRUCTION_SIZE = -11,

    ERROR_UNSUPPORTED_ARCH = -13,

    ERROR_SSE_FAILURE = -14,

    ERROR_FPU_STACK_OVERFLOW = -15,

    ERROR_INVALID_OPERAND = -16,

    ERROR_ALIGNMENT_FAULT = -17,

    ERROR_PRIVILEGED_INSTRUCTION = -18,

    ERROR_PAGE_FAULT = -19,

    ERROR_GENERAL_PROTECTION = -20,

    ERROR_INTEGER_OVERFLOW = -21,

    ERROR_INTEGER_UNDERFLOW = -22,

    ERROR_FLOAT_UNDERFLOW = -23,

    ERROR_FLOAT_DENORMAL = -24,

    ERROR_FLOAT_INVALID_OP = -25,

    ERROR_FLOAT_PRECISION = -26,

    ERROR_FLOAT_STACK_CHECK = -27,

    ERROR_SSE_ALIGNMENT = -28,

    ERROR_SSE_INVALID_OP = -29,

    ERROR_AVX_ALIGNMENT = -30,

    ERROR_AVX_INVALID_OP = -31,

    // Protector Logic Errors

    ERROR_AES_FAILURE = -32,

    ERROR_RANDOM_FAILURE = -33,

    ERROR_MEMORY_ALLOCATION = -34,

    ERROR_FILE_IO = -35,

    ERROR_CONFIG = -39,

    ERROR_CRYPTO_FAILURE = -46,

    ERROR_DISASSEMBLY_FAILURE = -47,

    ERROR_RECOMPILE_FAILURE = -48,

    ERROR_PATCH_FAILURE = -49,

    ERROR_LOADER_GENERATION_FAILURE = -50,

    ERROR_INSUFFICIENT_RESOURCES = -55,

    // Anti-Debugging and Anti-Analysis Errors

    ERROR_KERNEL_DEBUGGER_DETECTED = -12,

    ERROR_VM_DETECTED = -56,

    ERROR_TAMPERING_DETECTED = -57,

    // Placeholder errors for future expansion

    ERROR_NETWORK = -36,

    ERROR_DATABASE = -37,

    ERROR_UI = -38,

    ERROR_LICENSE = -40,

    ERROR_AUTHENTICATION = -41,

    ERROR_AUTHORIZATION = -42,

    ERROR_UNKNOWN = -100

};

// --- Core Data Structures ---

/**

 * @struct VMFlags

 * @brief Defines the state of the virtual CPU's arithmetic and control flags.

 */

struct VMFlags {

    bool zero = false; ///< Zero Flag (ZF): Set if the result of an operation is zero.

    bool carry = false; ///< Carry Flag (CF): Set on unsigned overflow.

    bool sign = false; ///< Sign Flag (SF): Set if the result is negative (MSB is 1).

    bool overflow = false; ///< Overflow Flag (OF): Set on signed overflow.

    bool parity = false; ///< Parity Flag (PF): Set if the number of set bits in the result is even.

};

/**

 * @struct u128

 * @brief Represents a 128-bit value, aligned to 16 bytes for SSE/AVX operations.

 */

struct alignas(16) u128 {

    uint64_t low; ///< The lower 64 bits of the value.

    uint64_t high; ///< The upper 64 bits of the value.

};

/**

 * @struct VMContext

 * @brief The complete context of the virtual machine at any point in time.

 * This structure holds all state necessary to execute virtualized code.

 */

struct VMContext {

    uint64_t regs[NUM_REGISTERS]; ///< General-purpose registers (R0-R15).

    u128 xmm_regs[NUM_REGISTERS]; ///< 128-bit SSE/AVX registers (XMM0-XMM15).

    uint8_t* ip; ///< Instruction Pointer: points into the VM bytecode.

    std::vector<uint8_t> stack; ///< The VM's private stack memory.

    size_t sp; ///< Stack Pointer: current top of the stack.

    VMFlags flags; ///< Emulated CPU flags.

    bool running; ///< VM execution state (true = run, false = halt).

    ProtectionError last_error; ///< Stores the code of the last error that occurred.

};

/**

 * @struct IRInstruction

 * @brief A simple Intermediate Representation (IR) for a single assembly instruction.

 * This is used when lifting native code into a format the recompiler can understand.

 */

struct IRInstruction {

    Opcodes opcode; ///< The VM opcode this instruction maps to.

    std::vector<std::string> operands; ///< String representations of the original operands.

    uint64_t original_address; ///< The address of the instruction in the original binary.

    size_t size; ///< The size of the original instruction in bytes.

};

/**

 * @struct AesGcmKey

 * @brief Holds handles for AES-GCM cryptography using the Windows CNG API.

 */

struct AesGcmKey {

    BCRYPT_ALG_HANDLE algHandle = NULL; ///< Handle to the CNG algorithm provider.

    BCRYPT_KEY_HANDLE keyHandle = NULL; ///< Handle to the specific encryption key.

};

/**

 * @struct ProtectorSettings

 * @brief Configuration options for the protection process.

 */

struct ProtectorSettings {

    bool enable_junk_insertion = true; ///< If true, junk opcodes will be inserted for obfuscation.

    bool enable_anti_debugging = true; ///< If true, anti-debugging checks will be embedded in the loader.

    bool enable_anti_vm = true; ///< If true, anti-virtual machine checks will be embedded.

    int junk_probability = JUNK_INSERTION_PROBABILITY; ///< The chance (0-100) of inserting junk code.

};

// --- Virtual Machine Opcodes ---

enum class Opcodes : uint16_t {

    NOP = 0x00, ADD = 0x01, SUB = 0x02, MUL = 0x03, DIV = 0x04, AND = 0x05, OR = 0x06,

    NOT = 0x07, SHL = 0x08, SHR = 0x09, XOR = 0x0A, LOAD = 0x0B, STORE = 0x0C, JMP = 0x0D,

    JZ = 0x0E, JNZ = 0x0F, JC = 0x10, JNC = 0x11, CMP = 0x12, INC = 0x13, DEC = 0x14,

    MOV = 0x15, LOAD_IMM = 0x16, PUSH = 0x17, POP = 0x18, CALL = 0x19, RET = 0x1A, IMUL = 0x1B,

    IDIV = 0x1C, SAR = 0x1D, ROL = 0x1E, ROR = 0x1F, TEST = 0x20, CMOVE = 0x21, CMOVNE = 0x22,

    LEA = 0x23, JBE = 0x24, JA = 0x25, JS = 0x26, JNS = 0x27, JO = 0x28, JNO = 0x29, JP = 0x2A,

    JNP = 0x2B, ADC = 0x2C, SBB = 0x2D, JLE = 0x2E, JG = 0x2F, NEG = 0x30, BSWAP = 0x31,

    POPCNT = 0x32, LZCNT = 0x33, TZCNT = 0x34, RCL = 0x35, RCR = 0x36, SHLD = 0x37, SHRD = 0x38,

    BT = 0x39, BTS = 0x3A, BTR = 0x3B, BTC = 0x3C, CMOVZ = 0x3D, CMOVNZ = 0x3E, SETZ = 0x3F,

    SETNZ = 0x40, SETC = 0x41, SETNC = 0x42, SETS = 0x43, SETNS = 0x44, SETO = 0x45, SETNO = 0x46,

    SETP = 0x47, SETNP = 0x48, SETBE = 0x49, SETA = 0x4A, SETLE = 0x4B, SETG = 0x4C, CMOVBE = 0x4D,

    CMOVA = 0x4E, CMOVS = 0x4F, CMOVNS = 0x50, CMOVO = 0x51, CMOVNO = 0x52, CMOVP = 0x53,

    CMOVNP = 0x54, CMOVLE = 0x55, CMOVG = 0x56, BSF = 0x57, BSR = 0x58, MOD = 0x59, IMOD = 0x5A,

    ADD32 = 0x5B, SUB32 = 0x5C, MUL32 = 0x5D, DIV32 = 0x5E, IMUL32 = 0x5F, IDIV32 = 0x60,

    MOD32 = 0x61, IMOD32 = 0x62, FADD = 0x63, FSUB = 0x64, FMUL = 0x65, FDIV = 0x66, FLD = 0x67,

    FST = 0x68, FCMP = 0x69, PADDD = 0x6A, PSUBD = 0x6B, PMULD = 0x6C, PDIVD = 0x6D,

    MOVDQA = 0x6E, PCMPEQD = 0x6F, PAND = 0x70, POR = 0x71, PXOR = 0x72, PSLLD = 0x73,

    PSRLD = 0x74, PSLLQ = 0x75, PSRLQ = 0x76, MOVDQU = 0x77, CVTSI2SD = 0x78, CVTSD2SI = 0x79,

    SQRTSD = 0x7A, MINSD = 0x7B, MAXSD = 0x7C, ANDPD = 0x7D, ORPD = 0x7E, XORPD = 0x7F,

    BLENDPD = 0x80, ROUNDPD = 0x81, VADDPD = 0x82, VSUBPD = 0x83, VMULPD = 0x84, VDIVPD = 0x85,

    VMOVAPD = 0x86, VCMP_PD = 0x87, VBROADCASTSD = 0x88, VPERMILPD = 0x89, VFMSUBADDPD = 0x8A,

    VMASKMOVPD = 0x8B, VGATHERDPD = 0x8C, VSCATTERDPD = 0x8D, VAESENC = 0x8E, VAESDEC = 0x8F,

    VPCLMULQDQ = 0x90, VPCMPEQD = 0x91, VPSHUFD = 0x92, VINSERTF128 = 0x93, VEXTRACTF128 = 0x94,

    VPERM2F128 = 0x95, VBLENDVPD = 0x96, PUSHF = 0x97, POPF = 0x98, CPUID = 0x99, RDTSC = 0x9A,

    XCHG = 0x9B, CLD = 0x9C, STD = 0x9D, CLI = 0x9E, STI = 0x9F, HLT = 0xA0, INT = 0xA1,

    IRET = 0xA2, LOOP = 0xA3, LOOPE = 0xA4, LOOPNE = 0xA5, OP_IN = 0xA6, OP_OUT = 0xA7,

    LAHF = 0xA8, SAHF = 0xA9, CLTS = 0xAA, LGDT = 0xAB, SGDT = 0xAC, LIDT = 0xAD, SIDT = 0xAE,

    LMSW = 0xAF, SMSW = 0xB0, RDMSR = 0xB1, WRMSR = 0xB2, RDPMC = 0xB3, RSM = 0xB4, UD2 = 0xB5,

    EMMS = 0xB6, MOVD = 0xB7, MOVQ = 0xB8, PACKSSWB = 0xB9, PACKSSDW = 0xBA, PACKUSWB = 0xBB,

    MMX_PADDQ = 0xBC, MMX_PADDB = 0xBD, MMX_PADDW = 0xBE, MMX_PADDD = 0xBF, MMX_PSUBB = 0xC0,

    MMX_PSUBW = 0xC1, MMX_PSUBD = 0xC2, MMX_PSUBQ = 0xC3, PMADDWD = 0xC4, PMULHW = 0xC5,

    PMULLW = 0xC6, PAVGB = 0xC7, PAVGW = 0xC8, PMINUB = 0xC9, PMAXUB = 0xCA, PMINSW = 0xCB,

    PMAXSW = 0xCC, PSADBW = 0xCD, PSHUFW = 0xCE, MASKMOVQ = 0xCF, MOVNTQ = 0xD0, PANDN = 0xD1,

    PCMPGTB = 0xD2, PCMPGTW = 0xD3, PCMPGTD = 0xD4, PEXTRW = 0xD5, PINSRW = 0xD6, PMADDUBSW = 0xD7,

    PMAXSD = 0xD8, PMINSD = 0xD9, PMULUDQ = 0xDA, PSHUFB = 0xDB, PSIGNB = 0xDC, PSIGNW = 0xDD,

    PSIGND = 0xDE, PSUBUSB = 0xDF, PSUBUSW = 0xE0, PSRLW = 0xE1, PSRAW = 0xE2, PSLLW = 0xE3,

    PSUBSB = 0xE4, PSUBSW = 0xE5, PUNPCKLBW = 0xE6, PUNPCKLWD = 0xE7, PUNPCKLDQ = 0xE8,

    PUNPCKHBW = 0xE9, PUNPCKHWD = 0xEA, PUNPCKHDQ = 0xEB, MOVD_EXT = 0xEC, MOVQ_EXT = 0xED,

    PMOVMSKB = 0xEE, PMULHRSW = 0xEF, PSHUFLW = 0xF0, PSHUFHW = 0xF1, PSLLDQ = 0xF2,

    PSRLDQ = 0xF3, PTEST = 0xF4, VADDPS = 0xF5, VSUBPS = 0xF6, VMULPS = 0xF7, VDIVPS = 0xF8,

    VANDPS = 0xF9, VORPS = 0xFA, VXORPS = 0xFB, VBLENDPS = 0xFC, VMINPS = 0xFD, VMAXPS = 0xFE,

    EXIT = 0xFF,

    // Junk Opcodes

    JUNK1 = 0x100, JUNK2 = 0x101, JUNK3 = 0x102, JUNK4 = 0x103, JUNK5 = 0x104,

    JUNK6 = 0x105, JUNK7 = 0x106, JUNK8 = 0x107, JUNK9 = 0x108, JUNK10 = 0x109,

    JUNK11 = 0x10A, JUNK12 = 0x10B, JUNK13 = 0x10C, JUNK14 = 0x10D, JUNK15 = 0x10E,

    JUNK16 = 0x10F, JUNK17 = 0x110, JUNK18 = 0x111, JUNK19 = 0x112, JUNK20 = 0x113

};

// --- Function Prototypes ---

// Section 1: Core Protection Workflow

void protect_function(const std::string& dll_path, uint64_t func_rva, const ProtectorSettings& settings);

void generate_loader(const std::string& protected_dll, const std::string& protected_meta, const ProtectorSettings& settings);

std::string generate_loader_source(const std::string& protected_dll, const std::string& protected_meta, const ProtectorSettings& settings);

// Section 2: Cryptography & Key Management

bool aesgcm_init(AesGcmKey& ctx, const BYTE* key, DWORD keyLen);

bool aesgcm_encrypt(AesGcmKey& ctx, const BYTE* pt, DWORD ptLen, const BYTE* iv, DWORD ivLen, std::vector<BYTE>& ct_out, std::vector<BYTE>& tag_out);

bool aesgcm_decrypt(AesGcmKey& ctx, const BYTE* ct, DWORD ctLen, const BYTE* iv, DWORD ivLen, const BYTE* tag, DWORD tagLen, std::vector<BYTE>& pt_out);

bool encrypt_file(const std::string& input_path, const std::string& output_path);

bool decrypt_file(const std::string& input_path, std::vector<uint8_t>& data_out);

void get_key(uint8_t key[AES_KEY_SIZE_BYTES]);

std::vector<uint8_t> generate_key_bytecode();

// Section 3: PE File & Memory Manipulation

bool patch_binary(const std::string& dll_path, uint64_t func_rva, const std::vector<uint8_t>& vm_bytecode);

HMODULE LoadLibraryMemory(const void* raw_data, size_t size);

PIMAGE_NT_HEADERS GetNtHeaders(LPVOID image_base);

PIMAGE_SECTION_HEADER FindSection(PIMAGE_NT_HEADERS nt_headers, const char* section_name);

DWORD RvaToOffset(PIMAGE_NT_HEADERS nt_headers, DWORD rva);

bool AddSectionToPe(const std::string& file_path, const char* section_name, DWORD size_of_section, PVOID section_data);

// Section 4: Disassembly and Recompilation

std::vector<std::string> disassemble_function(const uint8_t* buffer, size_t length, uint64_t runtime_address);

std::vector<IRInstruction> lift_to_ir(const std::vector<std::string>& disasm);

std::vector<uint8_t> recompile_to_vm(const std::vector<IRInstruction>& ir, const ProtectorSettings& settings);

std::map<std::string, uint8_t> get_reg_map();

// Section 5: VM Execution Core

using Handler = void (*)(VMContext* ctx, uint8_t* instr);

extern Handler g_handlers[0x114]; // Size must match number of opcodes

void bind_handlers();

void run_vm(VMContext* ctx, uint64_t max_steps = VM_EXECUTION_TIMEOUT);

void InitVM(VMContext& ctx, uint8_t* data, size_t data_size, std::ostream* log = nullptr);

// Section 6: Utilities

bool file_exists(const std::string& path);

std::vector<uint8_t> read_file_bytes(const std::string& path);

bool write_file_bytes(const std::string& path, const std::vector<uint8_t>& data);

std::string to_hex_string(uint64_t val);

double u64_to_double(uint64_t u);

uint64_t double_to_u64(double d);

bool parity_even(uint64_t x);

// Section 7: Anti-Analysis and Anti-Debugging Techniques

bool IsKernelDebuggerPresent(); // Using NtQuerySystemInformation

bool CheckRemoteDebuggerPresent(); // Using CheckRemoteDebuggerPresent

bool IsDebuggerPresentPEB(); // Manual check of PEB->BeingDebugged flag

bool CheckNtGlobalFlagPEB(); // Manual check of PEB->NtGlobalFlag

bool CheckHardwareBreakpoints(); // Using GetThreadContext and DR registers

bool CheckTimingAttack(); // Using RDTSC to detect debugger latency

bool CheckForVmware(); // Check for VMWare artifacts (e.g., MAC address, device names)

bool CheckForVirtualBox(); // Check for VirtualBox artifacts

bool CheckForSandboxie(); // Check for Sandboxie DLL

bool CheckForWireshark(); // Check if a common analysis tool is running

bool ObscureModuleNames(); // Hide module names in the PEB

void ErasePeHeadersFromMemory(); // Nuke PE headers of the loaded module to hinder dumping

// --- VM Opcode Handlers (Complete Prototype List) ---

// This section declares a handler function for every single opcode defined in the Opcodes enum.

// This ensures type safety and allows the dispatcher to be a simple array lookup.

// Basic Arithmetic and Logic

void handle_nop(VMContext* ctx, uint8_t* instr);

void handle_add(VMContext* ctx, uint8_t* instr);

void handle_sub(VMContext* ctx, uint8_t* instr);

void handle_mul(VMContext* ctx, uint8_t* instr);

void handle_div(VMContext* ctx, uint8_t* instr);

void handle_and(VMContext* ctx, uint8_t* instr);

void handle_or(VMContext* ctx, uint8_t* instr);

void handle_not(VMContext* ctx, uint8_t* instr);

void handle_shl(VMContext* ctx, uint8_t* instr);

void handle_shr(VMContext* ctx, uint8_t* instr);

void handle_xor(VMContext* ctx, uint8_t* instr);

void handle_imul(VMContext* ctx, uint8_t* instr);

void handle_idiv(VMContext* ctx, uint8_t* instr);

void handle_sar(VMContext* ctx, uint8_t* instr);

void handle_rol(VMContext* ctx, uint8_t* instr);

void handle_ror(VMContext* ctx, uint8_t* instr);

void handle_neg(VMContext* ctx, uint8_t* instr);

void handle_inc(VMContext* ctx, uint8_t* instr);

void handle_dec(VMContext* ctx, uint8_t* instr);

void handle_adc(VMContext* ctx, uint8_t* instr);

void handle_sbb(VMContext* ctx, uint8_t* instr);

// Memory and Data Movement

void handle_load(VMContext* ctx, uint8_t* instr);

void handle_store(VMContext* ctx, uint8_t* instr);

void handle_mov(VMContext* ctx, uint8_t* instr);

void handle_load_imm(VMContext* ctx, uint8_t* instr);

void handle_lea(VMContext* ctx, uint8_t* instr);

void handle_xchg(VMContext* ctx, uint8_t* instr);

void handle_bswap(VMContext* ctx, uint8_t* instr);

// Stack Operations

void handle_push(VMContext* ctx, uint8_t* instr);

void handle_pop(VMContext* ctx, uint8_t* instr);

void handle_pushf(VMContext* ctx, uint8_t* instr);

void handle_popf(VMContext* ctx, uint8_t* instr);

// Control Flow

void handle_jmp(VMContext* ctx, uint8_t* instr);

void handle_jz(VMContext* ctx, uint8_t* instr);

void handle_jnz(VMContext* ctx, uint8_t* instr);

void handle_jc(VMContext* ctx, uint8_t* instr);

void handle_jnc(VMContext* ctx, uint8_t* instr);

void handle_jbe(VMContext* ctx, uint8_t* instr);

void handle_ja(VMContext* ctx, uint8_t* instr);

void handle_js(VMContext* ctx, uint8_t* instr);

void handle_jns(VMContext* ctx, uint8_t* instr);

void handle_jo(VMContext* ctx, uint8_t* instr);

void handle_jno(VMContext* ctx, uint8_t* instr);

void handle_jp(VMContext* ctx, uint8_t* instr);

void handle_jnp(VMContext* ctx, uint8_t* instr);

void handle_jle(VMContext* ctx, uint8_t* instr);

void handle_jg(VMContext* ctx, uint8_t* instr);

void handle_call(VMContext* ctx, uint8_t* instr);

void handle_ret(VMContext* ctx, uint8_t* instr);

void handle_loop(VMContext* ctx, uint8_t* instr);

void handle_loope(VMContext* ctx, uint8_t* instr);

void handle_loopne(VMContext* ctx, uint8_t* instr);

// Comparison and Testing

void handle_cmp(VMContext* ctx, uint8_t* instr);

void handle_test(VMContext* ctx, uint8_t* instr);

void handle_bt(VMContext* ctx, uint8_t* instr);

void handle_bts(VMContext* ctx, uint8_t* instr);

void handle_btr(VMContext* ctx, uint8_t* instr);

void handle_btc(VMContext* ctx, uint8_t* instr);

// Conditional Moves

void handle_cmove(VMContext* ctx, uint8_t* instr);

void handle_cmovne(VMContext* ctx, uint8_t* instr);

void handle_cmovz(VMContext* ctx, uint8_t* instr);

void handle_cmovnz(VMContext* ctx, uint8_t* instr);

void handle_cmovbe(VMContext* ctx, uint8_t* instr);

void handle_cmova(VMContext* ctx, uint8_t* instr);

void handle_cmovs(VMContext* ctx, uint8_t* instr);

void handle_cmovns(VMContext* ctx, uint8_t* instr);

void handle_cmovo(VMContext* ctx, uint8_t* instr);

void handle_cmovno(VMContext* ctx, uint8_t* instr);

void handle_cmovp(VMContext* ctx, uint8_t* instr);

void handle_cmovnp(VMContext* ctx, uint8_t* instr);

void handle_cmovle(VMContext* ctx, uint8_t* instr);

void handle_cmovg(VMContext* ctx, uint8_t* instr);

// Set-Byte on Condition

void handle_setz(VMContext* ctx, uint8_t* instr);

void handle_setnz(VMContext* ctx, uint8_t* instr);

void handle_setc(VMContext* ctx, uint8_t* instr);

void handle_setnc(VMContext* ctx, uint8_t* instr);

void handle_sets(VMContext* ctx, uint8_t* instr);

void handle_setns(VMContext* ctx, uint8_t* instr);

void handle_seto(VMContext* ctx, uint8_t* instr);

void handle_setno(VMContext* ctx, uint8_t* instr);

void handle_setp(VMContext* ctx, uint8_t* instr);

void handle_setnp(VMContext* ctx, uint8_t* instr);

void handle_setbe(VMContext* ctx, uint8_t* instr);

void handle_seta(VMContext* ctx, uint8_t* instr);

void handle_setle(VMContext* ctx, uint8_t* instr);

void handle_setg(VMContext* ctx, uint8_t* instr);

// Bit Manipulation

void handle_popcnt(VMContext* ctx, uint8_t* instr);

void handle_lzcnt(VMContext* ctx, uint8_t* instr);

void handle_tzcnt(VMContext* ctx, uint8_t* instr);

void handle_rcl(VMContext* ctx, uint8_t* instr);

void handle_rcr(VMContext* ctx, uint8_t* instr);

void handle_shld(VMContext* ctx, uint8_t* instr);

void handle_shrd(VMContext* ctx, uint8_t* instr);

void handle_bsf(VMContext* ctx, uint8_t* instr);

void handle_bsr(VMContext* ctx, uint8_t* instr);

// 32-bit Operations

void handle_mod(VMContext* ctx, uint8_t* instr);

void handle_imod(VMContext* ctx, uint8_t* instr);

void handle_add32(VMContext* ctx, uint8_t* instr);

void handle_sub32(VMContext* ctx, uint8_t* instr);

void handle_mul32(VMContext* ctx, uint8_t* instr);

void handle_div32(VMContext* ctx, uint8_t* instr);

void handle_imul32(VMContext* ctx, uint8_t* instr);

void handle_idiv32(VMContext* ctx, uint8_t* instr);

void handle_mod32(VMContext* ctx, uint8_t* instr);

void handle_imod32(VMContext* ctx, uint8_t* instr);

// FPU (Floating Point) Operations

void handle_fadd(VMContext* ctx, uint8_t* instr);

void handle_fsub(VMContext* ctx, uint8_t* instr);

void handle_fmul(VMContext* ctx, uint8_t* instr);

void handle_fdiv(VMContext* ctx, uint8_t* instr);

void handle_fld(VMContext* ctx, uint8_t* instr);

void handle_fst(VMContext* ctx, uint8_t* instr);

void handle_fcmp(VMContext* ctx, uint8_t* instr);

// SSE/SSE2 Operations

void handle_paddd(VMContext* ctx, uint8_t* instr);

void handle_psubd(VMContext* ctx, uint8_t* instr);

void handle_pmuld(VMContext* ctx, uint8_t* instr);

void handle_pdivd(VMContext* ctx, uint8_t* instr); // Note: No direct SSE instruction for this

void handle_movdqa(VMContext* ctx, uint8_t* instr);

void handle_movdqu(VMContext* ctx, uint8_t* instr);

void handle_pcmpeqd(VMContext* ctx, uint8_t* instr);

void handle_pand(VMContext* ctx, uint8_t* instr);

void handle_por(VMContext* ctx, uint8_t* instr);

void handle_pxor(VMContext* ctx, uint8_t* instr);

void handle_pslld(VMContext* ctx, uint8_t* instr);

void handle_psrld(VMContext* ctx, uint8_t* instr);

void handle_psllq(VMContext* ctx, uint8_t* instr);

void handle_psrlq(VMContext* ctx, uint8_t* instr);

void handle_cvtsi2sd(VMContext* ctx, uint8_t* instr);

void handle_cvtsd2si(VMContext* ctx, uint8_t* instr);

void handle_sqrtsd(VMContext* ctx, uint8_t* instr);

void handle_minsd(VMContext* ctx, uint8_t* instr);

void handle_maxsd(VMContext* ctx, uint8_t* instr);

void handle_andpd(VMContext* ctx, uint8_t* instr);

void handle_orpd(VMContext* ctx, uint8_t* instr);

void handle_xorpd(VMContext* ctx, uint8_t* instr);

void handle_blendpd(VMContext* ctx, uint8_t* instr);

void handle_roundpd(VMContext* ctx, uint8_t* instr);

// AVX Operations

void handle_vaddpd(VMContext* ctx, uint8_t* instr);

void handle_vsubpd(VMContext* ctx, uint8_t* instr);

void handle_vmulpd(VMContext* ctx, uint8_t* instr);

void handle_vdivpd(VMContext* ctx, uint8_t* instr);

void handle_vmovapd(VMContext* ctx, uint8_t* instr);

void handle_vcmp_pd(VMContext* ctx, uint8_t* instr);

void handle_vbroadcastsd(VMContext* ctx, uint8_t* instr);

void handle_vpermilpd(VMContext* ctx, uint8_t* instr);

void handle_vfmsubaddpd(VMContext* ctx, uint8_t* instr);

void handle_vmaskmovpd(VMContext* ctx, uint8_t* instr);

void handle_vgatherdpd(VMContext* ctx, uint8_t* instr);

void handle_vscatterdpd(VMContext* ctx, uint8_t* instr);

void handle_vaesenc(VMContext* ctx, uint8_t* instr);

void handle_vaesdec(VMContext* ctx, uint8_t* instr);

void handle_vpclmulqdq(VMContext* ctx, uint8_t* instr);

void handle_vpcmpeqd(VMContext* ctx, uint8_t* instr);

void handle_vpshufd(VMContext* ctx, uint8_t* instr);

void handle_vinsertf128(VMContext* ctx, uint8_t* instr);

void handle_vextractf128(VMContext* ctx, uint8_t* instr);

void handle_vperm2f128(VMContext* ctx, uint8_t* instr);

void handle_vblendvpd(VMContext* ctx, uint8_t* instr);

void handle_vaddps(VMContext* ctx, uint8_t* instr);

void handle_vsubps(VMContext* ctx, uint8_t* instr);

void handle_vmulps(VMContext* ctx, uint8_t* instr);

void handle_vdivps(VMContext* ctx, uint8_t* instr);

void handle_vandps(VMContext* ctx, uint8_t* instr);

void handle_vorps(VMContext* ctx, uint8_t* instr);

void handle_vxorps(VMContext* ctx, uint8_t* instr);

void handle_vblendps(VMContext* ctx, uint8_t* instr);

void handle_vminps(VMContext* ctx, uint8_t* instr);

void handle_vmaxps(VMContext* ctx, uint8_t* instr);

// System and Control Instructions

void handle_cpuid(VMContext* ctx, uint8_t* instr);

void handle_rdtsc(VMContext* ctx, uint8_t* instr);

void handle_cld(VMContext* ctx, uint8_t* instr);

void handle_std(VMContext* ctx, uint8_t* instr);

void handle_cli(VMContext* ctx, uint8_t* instr);

void handle_sti(VMContext* ctx, uint8_t* instr);

void handle_hlt(VMContext* ctx, uint8_t* instr);

void handle_int(VMContext* ctx, uint8_t* instr);

void handle_iret(VMContext* ctx, uint8_t* instr);

void handle_op_in(VMContext* ctx, uint8_t* instr);

void handle_op_out(VMContext* ctx, uint8_t* instr);

void handle_lahf(VMContext* ctx, uint8_t* instr);

void handle_sahf(VMContext* ctx, uint8_t* instr);

void handle_clts(VMContext* ctx, uint8_t* instr);

void handle_lgdt(VMContext* ctx, uint8_t* instr);

void handle_sgdt(VMContext* ctx, uint8_t* instr);

void handle_lidt(VMContext* ctx, uint8_t* instr);

void handle_sidt(VMContext* ctx, uint8_t* instr);

void handle_lmsw(VMContext* ctx, uint8_t* instr);

void handle_smsw(VMContext* ctx, uint8_t* instr);

void handle_rdmsr(VMContext* ctx, uint8_t* instr);

void handle_wrmsr(VMContext* ctx, uint8_t* instr);

void handle_rdpmc(VMContext* ctx, uint8_t* instr);

void handle_rsm(VMContext* ctx, uint8_t* instr);

void handle_ud2(VMContext* ctx, uint8_t* instr);

// MMX Instructions

void handle_emms(VMContext* ctx, uint8_t* instr);

void handle_movd(VMContext* ctx, uint8_t* instr);

void handle_movq(VMContext* ctx, uint8_t* instr);

void handle_packsswb(VMContext* ctx, uint8_t* instr);

void handle_packssdw(VMContext* ctx, uint8_t* instr);

void handle_packuswb(VMContext* ctx, uint8_t* instr);

void handle_mmx_paddq(VMContext* ctx, uint8_t* instr);

void handle_mmx_paddb(VMContext* ctx, uint8_t* instr);

void handle_mmx_paddw(VMContext* ctx, uint8_t* instr);

void handle_mmx_paddd(VMContext* ctx, uint8_t* instr);

void handle_mmx_psubb(VMContext* ctx, uint8_t* instr);

void handle_mmx_psubw(VMContext* ctx, uint8_t* instr);

void handle_mmx_psubd(VMContext* ctx, uint8_t* instr);

void handle_mmx_psubq(VMContext* ctx, uint8_t* instr);

void handle_pmaddwd(VMContext* ctx, uint8_t* instr);

void handle_pmulhw(VMContext* ctx, uint8_t* instr);

void handle_pmullw(VMContext* ctx, uint8_t* instr);

void handle_pavgb(VMContext* ctx, uint8_t* instr);

void handle_pavgw(VMContext* ctx, uint8_t* instr);

void handle_pminub(VMContext* ctx, uint8_t* instr);

void handle_pmaxub(VMContext* ctx, uint8_t* instr);

void handle_pminsw(VMContext* ctx, uint8_t* instr);

void handle_pmaxsw(VMContext* ctx, uint8_t* instr);

void handle_psadbw(VMContext* ctx, uint8_t* instr);

void handle_pshufw(VMContext* ctx, uint8_t* instr);

void handle_maskmovq(VMContext* ctx, uint8_t* instr);

void handle_movntq(VMContext* ctx, uint8_t* instr);

void handle_pandn(VMContext* ctx, uint8_t* instr);

void handle_pcmpgtb(VMContext* ctx, uint8_t* instr);

void handle_pcmpgtw(VMContext* ctx, uint8_t* instr);

void handle_pcmpgtd(VMContext* ctx, uint8_t* instr);

void handle_pextrw(VMContext* ctx, uint8_t* instr);

void handle_pinsrw(VMContext* ctx, uint8_t* instr);

void handle_pmaddubsw(VMContext* ctx, uint8_t* instr);

void handle_pmaxsd(VMContext* ctx, uint8_t* instr);

void handle_pminsd(VMContext* ctx, uint8_t* instr);

void handle_pmuludq(VMContext* ctx, uint8_t* instr);

void handle_pshufb(VMContext* ctx, uint8_t* instr);

void handle_psignb(VMContext* ctx, uint8_t* instr);

void handle_psignw(VMContext* ctx, uint8_t* instr);

void handle_psignd(VMContext* ctx, uint8_t* instr);

void handle_psubusb(VMContext* ctx, uint8_t* instr);

void handle_psubusw(VMContext* ctx, uint8_t* instr);

void handle_psrlw(VMContext* ctx, uint8_t* instr);

void handle_psraw(VMContext* ctx, uint8_t* instr);

void handle_psllw(VMContext* ctx, uint8_t* instr);

void handle_psubsb(VMContext* ctx, uint8_t* instr);

void handle_psubsw(VMContext* ctx, uint8_t* instr);

void handle_punpcklbw(VMContext* ctx, uint8_t* instr);

void handle_punpcklwd(VMContext* ctx, uint8_t* instr);

void handle_punpckldq(VMContext* ctx, uint8_t* instr);

void handle_punpckhbw(VMContext* ctx, uint8_t* instr);

void handle_punpckhwd(VMContext* ctx, uint8_t* instr);

void handle_punpckhdq(VMContext* ctx, uint8_t* instr);

void handle_movd_ext(VMContext* ctx, uint8_t* instr);

void handle_movq_ext(VMContext* ctx, uint8_t* instr);

void handle_pmovmskb(VMContext* ctx, uint8_t* instr);

void handle_pmulhrsw(VMContext* ctx, uint8_t* instr);

void handle_pshuflw(VMContext* ctx, uint8_t* instr);

void handle_pshufhw(VMContext* ctx, uint8_t* instr);

void handle_pslldq(VMContext* ctx, uint8_t* instr);

void handle_psrldq(VMContext* ctx, uint8_t* instr);

void handle_ptest(VMContext* ctx, uint8_t* instr);

// VM Control and Junk

void handle_exit(VMContext* ctx, uint8_t* instr);

void handle_junk(VMContext* ctx, uint8_t* instr);

#endif // LOADER_CORE_H write the full loader core out the .cpp